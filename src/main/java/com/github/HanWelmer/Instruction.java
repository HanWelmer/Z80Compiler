/*
Copyright Â© 2023 Han Welmer.

This file is part of Z80Compiler.

Z80Compiler is free software: you can redistribute it and/or modify it under 
the terms of the GNU General Public License as published by the Free Software 
Foundation, either version 3 of the License, or (at your option) any later 
version.

Z80Compiler is distributed in the hope that it will be useful, but WITHOUT 
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with 
Z80Compiler. If not, see <https://www.gnu.org/licenses/>.
*/

package com.github.HanWelmer;

import java.util.EnumSet;

/**
 * This class defines an instruction for the M machine as generated by the P
 * language. Used in the code generation phase of the compiler.
 */
public class Instruction {
  public FunctionType function;
  public Operand operand;
  public Operand operand2;

  private EnumSet<FunctionType> noOperand = EnumSet.of(
      // special instructions:
      FunctionType.stop
      // Input and output instructions:
      , FunctionType.read, FunctionType.writeAcc8, FunctionType.writeAcc16, FunctionType.writeString, FunctionType.writeLineAcc8,
      FunctionType.writeLineAcc16, FunctionType.writeLineString
      // 8-bit instructions:
      , FunctionType.acc8CompareAcc16 // reverse compare
      // 16-bit instructions:
      , FunctionType.acc16CompareAcc8 // normal compare
      // 16/8-bit conversion:
      , FunctionType.acc8ToAcc16, FunctionType.acc16ToAcc8, FunctionType.stackAcc8ToAcc16, FunctionType.stackAcc16ToAcc8
      // stack instructions:
      , FunctionType.stackAcc8, FunctionType.stackAcc16, FunctionType.unstackAcc8, FunctionType.unstackAcc16);

  private EnumSet<FunctionType> oneOperand = EnumSet.of(
      // special instructions:
      FunctionType.stringConstant, FunctionType.comment, FunctionType.call, FunctionType.sleep
      // Input and output instructions:
      , FunctionType.input
      // 8-bit instructions:
      , FunctionType.acc8Store, FunctionType.acc8Load, FunctionType.stackAcc8Load, FunctionType.acc8Or, FunctionType.acc8Xor,
      FunctionType.acc8And, FunctionType.acc8Plus, FunctionType.acc8Minus, FunctionType.minusAcc8, FunctionType.acc8Compare // normal
                                                                                                                            // compare
      , FunctionType.revAcc8Compare // reverse compare
      , FunctionType.acc8Times, FunctionType.acc8Div, FunctionType.divAcc8, FunctionType.increment8, FunctionType.decrement8
      // 16-bit instructions:
      , FunctionType.acc16Store, FunctionType.acc16Load, FunctionType.stackAcc16Load, FunctionType.acc16Or, FunctionType.acc16Xor,
      FunctionType.acc16And, FunctionType.acc16Plus, FunctionType.acc16Minus, FunctionType.minusAcc16, FunctionType.acc16Compare // normal
                                                                                                                                 // compare
      , FunctionType.revAcc16Compare // reverse compare
      , FunctionType.acc16Times, FunctionType.acc16Div, FunctionType.divAcc16, FunctionType.increment16, FunctionType.decrement16
      // branch instructions:
      , FunctionType.br, FunctionType.brEq, FunctionType.brNe, FunctionType.brLt, FunctionType.brLe, FunctionType.brGt,
      FunctionType.brGe);

  private EnumSet<FunctionType> twoOperands = EnumSet.of(
      // Input and output instructions:
      FunctionType.output);

  public Instruction(FunctionType fn) {
    function = fn;

    // error detection (internal compiler errors):
    if (oneOperand.contains(function)) {
      throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
    }
    if (twoOperands.contains(function)) {
      throw new RuntimeException("Internal compiler error: functionType " + fn + " expects two operands.");
    }
  }

  public Instruction(FunctionType fn, Operand operand) {
    if (noOperand.contains(function)) {
      throw new RuntimeException("Internal compiler error: functionType " + fn + " expects no operands.");
    }
    if (twoOperands.contains(function)) {
      throw new RuntimeException("Internal compiler error: functionType " + fn + " expects two operands.");
    }

    // error detection (internal compiler errors):
    switch (fn) {
      case input:
        if ((operand == null) || (operand.opType != OperandType.constant) || (operand.datatype != Datatype.byt)) {
          throw new RuntimeException(
              "Internal compiler error: functionType " + fn + " expects constant byte value for port parameter.");
        }
        break;
      case sleep:
        if ((operand == null) || !((operand.datatype == Datatype.byt) || (operand.datatype == Datatype.word))) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects byte or word value.");
        }
        break;
      case call:
        throw new RuntimeException("Internal compiler error: functionType " + fn + " not yet implemented.");
      // break;
      case comment:
        if (operand == null) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
        }
        ;
        if (operand.opType != OperandType.constant) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects a constant operand.");
        }
        ;
        if (operand.datatype != Datatype.string || operand.strValue == null) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects a string constant operand.");
        }
        ;
        break;
      case stringConstant:
        if (operand == null) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
        }
        ;
        if (operand.intValue == null) {
          throw new RuntimeException("Internal compiler error: " + fn + " needs an intValue.");
        }
        ;
        if (operand.strValue == null) {
          throw new RuntimeException("Internal compiler error: " + fn + " needs an strValue.");
        }
        ;
        break;
      case acc16Store:
        if (operand == null) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
        }
        if (operand.opType != OperandType.stack16 && operand.opType != OperandType.var) {
          throw new RuntimeException(
              "Internal compiler error: illegal operand type " + operand.opType + " for functionType " + fn + ".");
        }
        if (operand.opType == OperandType.var && operand.intValue == null) {
          throw new RuntimeException(
              "Internal compiler error: functionType " + fn + " expects an address for its variable operand.");
        }
        break;
      case acc8Store:
        if (operand == null) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
        }
        if (operand.opType != OperandType.stack8 && operand.opType != OperandType.var) {
          throw new RuntimeException(
              "Internal compiler error: illegal operand type " + operand.opType + " for functionType " + fn + ".");
        }
        if (operand.opType == OperandType.var && operand.intValue == null) {
          throw new RuntimeException(
              "Internal compiler error: functionType " + fn + " expects an address for its variable operand.");
        }
        break;
      case stackAcc16Load:
        if (operand != null && operand.opType == OperandType.stack16) {
          throw new RuntimeException("Internal compiler error: illegal stack operand for functionType " + fn + ".");
        }
        // ga verder met controles voor non-stack load.
      case acc16Load:
        if (operand == null) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
        }
        if (operand.opType == OperandType.stack16) {
          // no error.
        } else if (operand.opType == OperandType.constant && operand.intValue != null) {
          // no error.
        } else if (operand.opType == OperandType.var && operand.intValue != null) {
          // no error.
        } else if (operand.opType == OperandType.acc && operand.datatype == Datatype.word) {
          // no error.
        } else {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " with " + operand + ".");
        }
        break;
      case stackAcc8Load:
        if (operand != null && operand.opType == OperandType.stack8) {
          throw new RuntimeException("Internal compiler error: illegal stack operand for functionType " + fn + ".");
        }
        // ga verder met controles voor non-stack load.
      case acc8Load:
        if (operand == null) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
        }
        if (operand.opType == OperandType.stack8) {
          // no error.
        } else if (operand.opType == OperandType.constant && operand.intValue != null) {
          // no error.
        } else if (operand.opType == OperandType.var && operand.intValue != null) {
          // no error.
        } else if (operand.opType == OperandType.acc && operand.datatype == Datatype.byt) {
          // no error.
        } else {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " with " + operand + ".");
        }
        break;
      case acc16Or:
      case acc16Xor:
      case acc16And:
      case acc16Plus:
      case acc16Minus:
      case minusAcc16:
      case acc16Times:
      case acc16Div:
      case divAcc16:
      case acc16Compare: // normal compare
      case revAcc16Compare: // reverse compare
      case acc8Or:
      case acc8Xor:
      case acc8And:
      case acc8Plus:
      case acc8Minus:
      case minusAcc8:
      case acc8Times:
      case acc8Div:
      case divAcc8:
      case acc8Compare:
      case revAcc8Compare:
        if (operand == null) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
        }
        switch (operand.opType) {
          case stack8:
            break;
          case stack16:
            break;
          case constant:
            if (operand.datatype != Datatype.byt && operand.datatype != Datatype.word) {
              throw new RuntimeException(
                  "Internal compiler error: functionType " + fn + " expects an word or byte datatype for its constant operand.");
            }
            if (operand.intValue == null) {
              throw new RuntimeException(
                  "Internal compiler error: functionType " + fn + " expects an word value for its constant operand.");
            }
            break;
          case var:
            if (operand.intValue == null) {
              throw new RuntimeException(
                  "Internal compiler error: functionType " + fn + " expects an address for its variable operand.");
            }
            break;
          case acc:
            if (operand.datatype == Datatype.byt || operand.datatype == Datatype.word) {
              // no error.
            } else {
              throw new RuntimeException("Internal compiler error: functionType " + fn + " with " + operand + ".");
            }
            break;
          default:
            new RuntimeException("unknown operand type");
        }
        break;
      case increment16:
      case decrement16:
      case increment8:
      case decrement8:
        if (operand != null && operand.opType == OperandType.var) {
          if (operand.intValue == null) {
            throw new RuntimeException(
                "Internal compiler error: functionType " + fn + " expects an address for its variable operand.");
          }
        } else {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects a variable as operand.");
        }
        ;
        break;
      case br:
      case brEq:
      case brNe:
      case brLt:
      case brLe:
      case brGt:
      case brGe:
        if (operand != null && operand.opType == OperandType.label) {
          if (operand.intValue == null) {
            throw new RuntimeException(
                "Internal compiler error: functionType " + fn + " expects the address of a label to jump to.");
          }
        } else {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects a label to jump to.");
        }
        ;
        break;
      default:
        throw new RuntimeException("Internal compiler error: unknown functionType " + fn);
    }

    // copy parameter fn to member function.
    function = fn;
    // deep copy of parameter operand to member operand, otherwise a reference
    // to the mutable object operand is copied into the Instruction.
    this.operand = deepCopy(operand);
  }

  public Instruction(FunctionType fn, Operand operand1, Operand operand2) {
    // error detection (internal compiler errors):
    if (noOperand.contains(function)) {
      throw new RuntimeException("Internal compiler error: functionType " + fn + " expects no operands.");
    }
    if (oneOperand.contains(function)) {
      throw new RuntimeException("Internal compiler error: functionType " + fn + " expects one operands.");
    }

    if (fn == FunctionType.output) {
      // Instruction(FunctionType.output, port, value)
      if ((operand1 == null) || (operand1.datatype != Datatype.byt)) {
        throw new RuntimeException("Internal compiler error: functionType " + fn + " expects byte value for port parameter.");
      }
      if ((operand2 == null) || (operand2.datatype != Datatype.byt)) {
        throw new RuntimeException("Internal compiler error: functionType " + fn + " expects byte value for value parameter.");
      }
    } else {
      throw new RuntimeException("Internal compiler error: functionType " + fn + " doesn't expect two operand.");
    }

    // copy parameter fn to member function.
    function = fn;
    // deep copy of parameter operand to member operand, otherwise a reference
    // to the mutable object operand is copied into the Instruction.
    this.operand = deepCopy(operand1);
    this.operand2 = deepCopy(operand2);
  }

  protected Operand deepCopy(Operand operand) {
    Operand newOperand;
    if (operand.datatype == Datatype.string) {
      newOperand = new Operand(operand.opType, operand.datatype, operand.intValue);
      newOperand.strValue = operand.strValue;
    } else if (operand.datatype == Datatype.word || operand.datatype == Datatype.byt) {
      newOperand = new Operand(operand.opType, operand.datatype, operand.intValue);
    } else {
      newOperand = new Operand(operand.opType, operand.datatype, operand.strValue);
    }
    newOperand.isFinal = operand.isFinal;
    return newOperand;
  }

  public String toString() {
    String result = function.getValue();
    switch (function) {
      case comment:
        result += operand.strValue;
        break;
      case stringConstant:
        result += " " + operand.intValue + " = \"" + operand.strValue + "\"";
        break;
      case acc16Store:
      case acc8Store:
        switch (operand.opType) {
          case var:
            result += " variable " + operand.intValue;
            break;
          case stack16:
          case stack8:
            result += " " + operand.opType;
            break;
          default:
            throw new RuntimeException("accStore with unsupported operandType");
        }
        ;
        break;
      case acc16Load:
      case stackAcc16Load:
      case acc16Or:
      case acc16Xor:
      case acc16And:
      case acc16Plus:
      case acc16Minus:
      case minusAcc16:
      case acc16Times:
      case acc16Div:
      case divAcc16:
      case acc16Compare: // normal compare
      case revAcc16Compare: // reverse compare
      case acc8Load:
      case stackAcc8Load:
      case acc8Or:
      case acc8Xor:
      case acc8And:
      case acc8Plus:
      case acc8Minus:
      case minusAcc8:
      case acc8Times:
      case acc8Div:
      case divAcc8:
      case acc8Compare: // normal compare
      case revAcc8Compare: // reverse compare
        switch (operand.opType) {
          case var:
            result += " variable " + operand.intValue;
            break;
          case constant:
            result += " constant " + operand.intValue;
            break;
          case stack16:
          case stack8:
            if (operand.datatype == Datatype.byt) {
              result += " unstack8";
            } else if (operand.datatype == Datatype.word) {
              result += " unstack16";
            }
            break;
          case acc:
            if (operand.datatype == Datatype.byt) {
              result += " acc8";
            } else if (operand.datatype == Datatype.word) {
              result += " acc16";
            }
            break;
          default:
            throw new RuntimeException("accu related instruction with unsupported operandType");
        }
        ;
        break;
      case increment16:
      case decrement16:
      case increment8:
      case decrement8:
        switch (operand.opType) {
          case var:
            result += " variable " + operand.intValue;
            break;
          default:
            throw new RuntimeException(result + " instruction with non-var operandType");
        }
        ;
        break;
      case br:
      case brNe:
      case brEq:
      case brLt:
      case brLe:
      case brGe:
      case brGt:
      case sleep:
      case call:
        result += " " + operand.intValue;
        break;
      case read:
        result = "call read";
        break;
      case writeAcc8:
        result = "call writeAcc8";
        break;
      case writeAcc16:
        result = "call writeAcc16";
        break;
      case writeString:
        result = "writeString";
        break;
      case writeLineAcc8:
        result = "call writeLineAcc8";
        break;
      case writeLineAcc16:
        result = "call writeLineAcc16";
        break;
      case writeLineString:
        result = "writeLineString";
        break;
      case stop:
      case acc16CompareAcc8:
      case acc8CompareAcc16:
      case acc16ToAcc8:
      case acc8ToAcc16:
      case stackAcc16ToAcc8:
      case stackAcc8ToAcc16:
      case stackAcc16:
      case stackAcc8:
      case unstackAcc16:
      case unstackAcc8:
        break;
      case input:
        // input: port = operand.
        // Template Z80S180 code:
        // IN0 A,(port)
        switch (operand.opType) {
          case constant:
            result += String.format(" port 0x%1$02X", operand.intValue);
            break;
          // case var:
          // result += " port variable " + operand.intValue;
          // break;
          // case stack8:
          // result += " port " + operand.opType;
          // break;
          default:
            throw new RuntimeException("output with unsupported operandType for port operand");
        }
        ;
        break;
      case output:
        // output: port = operand, value = operand2.
        // Template Z80S180 code:
        // LD A,value
        // OUT0 (port),A
        switch (operand.opType) {
          case constant:
            result += String.format(" port 0x%1$02X", operand.intValue);
            break;
          // case var:
          // result += " port variable " + operand.intValue;
          // break;
          // case stack8:
          // result += " port " + operand.opType;
          // break;
          default:
            throw new RuntimeException("output with unsupported operandType for port operand");
        }
        ;
        switch (operand2.opType) {
          case constant:
            result += String.format(" value 0x%1$02X", operand2.intValue);
            break;
          case acc:
            if (operand2.datatype == Datatype.byt) {
              result += ", value acc8";
            } else {
              throw new RuntimeException("output with unsupported datatype for value operand");
            }
            break;
          case var:
            result += ", value variable " + operand2.intValue;
            break;
          case stack8:
            result += ", value " + operand2.opType;
            break;
          default:
            throw new RuntimeException("output with unsupported operandType for value operand");
        }
        ;
        break;
      default:
        throw new RuntimeException("unsupported instruction");
    }
    return result;
  }
}
