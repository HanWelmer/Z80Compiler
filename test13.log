
prog: start
<-/* Program to test generated Z80 assembler code */
<-class TestOutputInput {
getLexeme=class, sourceLineNr=2

getLexeme=identifier TestOutputInput, sourceLineNr=2

prog: class declared: TestOutputInput
getLexeme={, sourceLineNr=2

<-
<-  println(0);
getLexeme=println, sourceLineNr=4

statements: start with stopSet = [endLexeme]
statement: start with stopSet = [endLexeme]
label: address = 0, compensated for comments = 4
printlnStatement: start with stopSet = [endLexeme]
getLexeme=(, sourceLineNr=4

getLexeme=constant byte 0, sourceLineNr=4

factor 1: acc16InUse = false, acc8InUse = false
getLexeme=), sourceLineNr=4

factor: end: operand(constant, type=byt, intValue=0, final=false), acc16InUse = false, acc8InUse = false
expressionWithOperand: start with followSet = [semicolon, rbracket, addop, endLexeme]
expressionWithOperand: operand(constant, type=byt, intValue=0, final=false), acc16InUse = false, acc8InUse = false
expressionWithOperand: end: operand(constant, type=byt, intValue=0, final=false), acc16InUse = false, acc8InUse = false
printlnStatement: operand(constant, type=byt, intValue=0, final=false)
->plant (acc8InUse=false, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=4, linesOfSourceCode=4):
   0 ;test13.j(0) /* Program to test generated Z80 assembler code */
   1 ;test13.j(1) class TestOutputInput {
   2 ;test13.j(2) 
   3 ;test13.j(3)   println(0);
   4 acc8= constant 0 ;acc8Load operand(constant, type=byt, intValue=0, final=false) ; stackedDatatypes=[]
->plant (acc8InUse=true, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=4, linesOfSourceCode=0):
   5 call writeLineAcc8 ;writeLineAcc8 ; stackedDatatypes=[]
getLexeme=;, sourceLineNr=4

<-  
<-  // Possible operand types: constant, acc, var, stack8.
<-  
<-  //constant + decimal constant
<-  output(2, 1);
getLexeme=output, sourceLineNr=9

printlnStatement: end
statement: end, firstAddress = 4
statement: start with stopSet = [endLexeme]
label: address = 6, compensated for comments = 11
outputStatement: start with stopSet = [endLexeme]
getLexeme=(, sourceLineNr=9

getLexeme=constant byte 2, sourceLineNr=9

expression: start with stopSet = [comma, semicolon, rbracket, endLexeme]
term: start with stopSet = [comma, semicolon, rbracket, addop, endLexeme]
factor 1: acc16InUse = false, acc8InUse = false
getLexeme=,, sourceLineNr=9

factor: end: operand(constant, type=byt, intValue=2, final=false), acc16InUse = false, acc8InUse = false
termWithOperand: start with followSet = [comma, semicolon, rbracket, addop, endLexeme]
term: operand(constant, type=byt, intValue=2, final=false), acc16InUse = false, acc8InUse = false
termWithOperand: end: operand(constant, type=byt, intValue=2, final=false), acc16InUse = false, acc8InUse = false
term: end
expressionWithOperand: start with followSet = [comma, semicolon, rbracket, addop, endLexeme]
expressionWithOperand: operand(constant, type=byt, intValue=2, final=false), acc16InUse = false, acc8InUse = false
expressionWithOperand: end: operand(constant, type=byt, intValue=2, final=false), acc16InUse = false, acc8InUse = false
expression: end
outputStatement: port = operand(constant, type=byt, intValue=2, final=false), final = false, acc16InUse = false, acc8InUse = false
getLexeme=constant byte 1, sourceLineNr=9

expression: start with stopSet = [semicolon, rbracket, endLexeme]
term: start with stopSet = [semicolon, rbracket, addop, endLexeme]
factor 1: acc16InUse = false, acc8InUse = false
getLexeme=), sourceLineNr=9

factor: end: operand(constant, type=byt, intValue=1, final=false), acc16InUse = false, acc8InUse = false
termWithOperand: start with followSet = [semicolon, rbracket, addop, endLexeme]
term: operand(constant, type=byt, intValue=1, final=false), acc16InUse = false, acc8InUse = false
termWithOperand: end: operand(constant, type=byt, intValue=1, final=false), acc16InUse = false, acc8InUse = false
term: end
expressionWithOperand: start with followSet = [semicolon, rbracket, addop, endLexeme]
expressionWithOperand: operand(constant, type=byt, intValue=1, final=false), acc16InUse = false, acc8InUse = false
expressionWithOperand: end: operand(constant, type=byt, intValue=1, final=false), acc16InUse = false, acc8InUse = false
expression: end
outputStatement: value = operand(constant, type=byt, intValue=1, final=false), acc16InUse = false, acc8InUse = false
->plant (acc8InUse=false, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=9, linesOfSourceCode=5):
   6 ;test13.j(4)   
   7 ;test13.j(5)   // Possible operand types: constant, acc, var, stack8.
   8 ;test13.j(6)   
   9 ;test13.j(7)   //constant + decimal constant
  10 ;test13.j(8)   output(2, 1);
  11 output port 0x02 value 0x01 ;output operand(constant, type=byt, intValue=2, final=false) ; stackedDatatypes=[]
getLexeme=;, sourceLineNr=9

<-  println(3);
getLexeme=println, sourceLineNr=10

output: end
statement: end, firstAddress = 11
statement: start with stopSet = [endLexeme]
label: address = 12, compensated for comments = 13
printlnStatement: start with stopSet = [endLexeme]
getLexeme=(, sourceLineNr=10

getLexeme=constant byte 3, sourceLineNr=10

factor 1: acc16InUse = false, acc8InUse = false
getLexeme=), sourceLineNr=10

factor: end: operand(constant, type=byt, intValue=3, final=false), acc16InUse = false, acc8InUse = false
expressionWithOperand: start with followSet = [semicolon, rbracket, addop, endLexeme]
expressionWithOperand: operand(constant, type=byt, intValue=3, final=false), acc16InUse = false, acc8InUse = false
expressionWithOperand: end: operand(constant, type=byt, intValue=3, final=false), acc16InUse = false, acc8InUse = false
printlnStatement: operand(constant, type=byt, intValue=3, final=false)
->plant (acc8InUse=false, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=10, linesOfSourceCode=1):
  12 ;test13.j(9)   println(3);
  13 acc8= constant 3 ;acc8Load operand(constant, type=byt, intValue=3, final=false) ; stackedDatatypes=[]
->plant (acc8InUse=true, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=10, linesOfSourceCode=0):
  14 call writeLineAcc8 ;writeLineAcc8 ; stackedDatatypes=[]
getLexeme=;, sourceLineNr=10

<-
<-  //final variable + hexadecimal constant
<-  final byte port = 0x05;
getLexeme=final, sourceLineNr=13

printlnStatement: end
statement: end, firstAddress = 13
statement: start with stopSet = [endLexeme]
label: address = 15, compensated for comments = 18
assignment: start with stopSet = [endLexeme]; lexeme.type=finalLexeme
getLexeme=byte, sourceLineNr=13

getLexeme=identifier port, sourceLineNr=13

assignment: final identifier port{byte}@0
update: start with stopSet = [endLexeme]
update: leftOperand = operand(var, type=byt, intValue=0, final=true)
getLexeme==, sourceLineNr=13

getLexeme=constant byte 5, sourceLineNr=13

expression: start with stopSet = [endLexeme]
term: start with stopSet = [addop, endLexeme]
factor 1: acc16InUse = false, acc8InUse = false
getLexeme=;, sourceLineNr=13

factor: end: operand(constant, type=byt, intValue=5, final=false), acc16InUse = false, acc8InUse = false
termWithOperand: start with followSet = [addop, endLexeme]
term: operand(constant, type=byt, intValue=5, final=false), acc16InUse = false, acc8InUse = false
termWithOperand: end: operand(constant, type=byt, intValue=5, final=false), acc16InUse = false, acc8InUse = false
term: end
expressionWithOperand: start with followSet = [addop, endLexeme]
expressionWithOperand: operand(constant, type=byt, intValue=5, final=false), acc16InUse = false, acc8InUse = false
expressionWithOperand: end: operand(constant, type=byt, intValue=5, final=false), acc16InUse = false, acc8InUse = false
expression: end
update assignment: var = var(port, datatype=byt, isFinal=true, intValue=0, address=0), operand = operand(constant, type=byt, intValue=5, final=false)
update: final var [port] = 5
update: end
<-  output(port, 0x04);
getLexeme=output, sourceLineNr=14

assignment: end
statement: end, firstAddress = 18
statement: start with stopSet = [endLexeme]
label: address = 15, compensated for comments = 19
outputStatement: start with stopSet = [endLexeme]
getLexeme=(, sourceLineNr=14

getLexeme=identifier port, sourceLineNr=14

expression: start with stopSet = [comma, semicolon, rbracket, endLexeme]
term: start with stopSet = [comma, semicolon, rbracket, addop, endLexeme]
factor 1: acc16InUse = false, acc8InUse = false
getLexeme=,, sourceLineNr=14

factor: end: operand(var, type=byt, intValue=0, strValue=port, final=true), acc16InUse = false, acc8InUse = false
termWithOperand: start with followSet = [comma, semicolon, rbracket, addop, endLexeme]
term: operand(var, type=byt, intValue=0, strValue=port, final=true), acc16InUse = false, acc8InUse = false
termWithOperand: end: operand(var, type=byt, intValue=0, strValue=port, final=true), acc16InUse = false, acc8InUse = false
term: end
expressionWithOperand: start with followSet = [comma, semicolon, rbracket, addop, endLexeme]
expressionWithOperand: operand(var, type=byt, intValue=0, strValue=port, final=true), acc16InUse = false, acc8InUse = false
expressionWithOperand: end: operand(var, type=byt, intValue=0, strValue=port, final=true), acc16InUse = false, acc8InUse = false
expression: end
outputStatement: port = operand(var, type=byt, intValue=0, strValue=port, final=true), final = true, acc16InUse = false, acc8InUse = false
getLexeme=constant byte 4, sourceLineNr=14

expression: start with stopSet = [semicolon, rbracket, endLexeme]
term: start with stopSet = [semicolon, rbracket, addop, endLexeme]
factor 1: acc16InUse = false, acc8InUse = false
getLexeme=), sourceLineNr=14

factor: end: operand(constant, type=byt, intValue=4, final=false), acc16InUse = false, acc8InUse = false
termWithOperand: start with followSet = [semicolon, rbracket, addop, endLexeme]
term: operand(constant, type=byt, intValue=4, final=false), acc16InUse = false, acc8InUse = false
termWithOperand: end: operand(constant, type=byt, intValue=4, final=false), acc16InUse = false, acc8InUse = false
term: end
expressionWithOperand: start with followSet = [semicolon, rbracket, addop, endLexeme]
expressionWithOperand: operand(constant, type=byt, intValue=4, final=false), acc16InUse = false, acc8InUse = false
expressionWithOperand: end: operand(constant, type=byt, intValue=4, final=false), acc16InUse = false, acc8InUse = false
expression: end
outputStatement: value = operand(constant, type=byt, intValue=4, final=false), acc16InUse = false, acc8InUse = false
->plant (acc8InUse=false, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=14, linesOfSourceCode=4):
  15 ;test13.j(10) 
  16 ;test13.j(11)   //final variable + hexadecimal constant
  17 ;test13.j(12)   final byte port = 0x05;
  18 ;test13.j(13)   output(port, 0x04);
  19 output port 0x05 value 0x04 ;output operand(constant, type=byt, intValue=5, final=false) ; stackedDatatypes=[]
getLexeme=;, sourceLineNr=14

<-  println(6);
getLexeme=println, sourceLineNr=15

output: end
statement: end, firstAddress = 19
statement: start with stopSet = [endLexeme]
label: address = 20, compensated for comments = 21
printlnStatement: start with stopSet = [endLexeme]
getLexeme=(, sourceLineNr=15

getLexeme=constant byte 6, sourceLineNr=15

factor 1: acc16InUse = false, acc8InUse = false
getLexeme=), sourceLineNr=15

factor: end: operand(constant, type=byt, intValue=6, final=false), acc16InUse = false, acc8InUse = false
expressionWithOperand: start with followSet = [semicolon, rbracket, addop, endLexeme]
expressionWithOperand: operand(constant, type=byt, intValue=6, final=false), acc16InUse = false, acc8InUse = false
expressionWithOperand: end: operand(constant, type=byt, intValue=6, final=false), acc16InUse = false, acc8InUse = false
printlnStatement: operand(constant, type=byt, intValue=6, final=false)
->plant (acc8InUse=false, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=15, linesOfSourceCode=1):
  20 ;test13.j(14)   println(6);
  21 acc8= constant 6 ;acc8Load operand(constant, type=byt, intValue=6, final=false) ; stackedDatatypes=[]
->plant (acc8InUse=true, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=15, linesOfSourceCode=0):
  22 call writeLineAcc8 ;writeLineAcc8 ; stackedDatatypes=[]
getLexeme=;, sourceLineNr=15

<-
<-  println("Klaar");
getLexeme=println, sourceLineNr=17

printlnStatement: end
statement: end, firstAddress = 21
statement: start with stopSet = [endLexeme]
label: address = 23, compensated for comments = 25
printlnStatement: start with stopSet = [endLexeme]
getLexeme=(, sourceLineNr=17

getLexeme=stringConstant "Klaar", sourceLineNr=17

factor 1: acc16InUse = false, acc8InUse = false
lexeme = stringConstant "Klaar"
factor: string constant 0 = "Klaar"
getLexeme=), sourceLineNr=17

lexeme = )
factor: end: operand(constant, type=string, intValue=0, strValue="Klaar", final=false), acc16InUse = false, acc8InUse = false
printlnStatement: operand(constant, type=string, intValue=0, strValue="Klaar", final=false), lexeme=)
->plant (acc8InUse=false, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=17, linesOfSourceCode=2):
  23 ;test13.j(15) 
  24 ;test13.j(16)   println("Klaar");
  25 acc16= constant 0 ;acc16Load operand(constant, type=string, intValue=0, strValue="Klaar", final=false) ; stackedDatatypes=[]
->plant (acc8InUse=false, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=17, linesOfSourceCode=0):
  26 writeLineString ;writeLineString ; stackedDatatypes=[]
getLexeme=;, sourceLineNr=17

<-}
getLexeme=}, sourceLineNr=18

printlnStatement: end
statement: end, firstAddress = 25
statements: end, firstAddress = 4
  27 ;test13.j(17) }
prog: end
->plant (acc8InUse=false, acc16InUse=false, lastSourceLineNr=0, sourceLineNr=18, linesOfSourceCode=0):
  28 stop ;stop ; stackedDatatypes=[]

optimize: start m-code optimization. Number of instructions before optimization = 29
optimize: end. Number of instructions after optimization = 29

Updating reference to string constant at 25 from 0 to 29

String constants cross reference list:
29 : [25]

transcoding to Z80: ;test13.j(0) /* Program to test generated Z80 assembler code */
transcoding to Z80: ;test13.j(1) class TestOutputInput {
transcoding to Z80: ;test13.j(2) 
transcoding to Z80: ;test13.j(3)   println(0);
transcoding to Z80: acc8= constant 0
..function: acc8Load
..asm: 021C9H        ;acc8= constant 0
..asm: 021C9H        LD    A,0
transcoding to Z80: call writeLineAcc8
..function: writeLineAcc8
..asm: 021CBH        ;call writeLineAcc8
..asm: 021CBH        CALL  writeLineA
transcoding to Z80: ;test13.j(4)   
transcoding to Z80: ;test13.j(5)   // Possible operand types: constant, acc, var, stack8.
transcoding to Z80: ;test13.j(6)   
transcoding to Z80: ;test13.j(7)   //constant + decimal constant
transcoding to Z80: ;test13.j(8)   output(2, 1);
transcoding to Z80: output port 0x02 value 0x01
..function: output
..asm: 021CEH        ;output port 0x02 value 0x01
..asm: 021CEH        LD    A,1
..asm: 021D0H        OUT0  (002H),A
transcoding to Z80: ;test13.j(9)   println(3);
transcoding to Z80: acc8= constant 3
..function: acc8Load
..asm: 021D3H        ;acc8= constant 3
..asm: 021D3H        LD    A,3
transcoding to Z80: call writeLineAcc8
..function: writeLineAcc8
..asm: 021D5H        ;call writeLineAcc8
..asm: 021D5H        CALL  writeLineA
transcoding to Z80: ;test13.j(10) 
transcoding to Z80: ;test13.j(11)   //final variable + hexadecimal constant
transcoding to Z80: ;test13.j(12)   final byte port = 0x05;
transcoding to Z80: ;test13.j(13)   output(port, 0x04);
transcoding to Z80: output port 0x05 value 0x04
..function: output
..asm: 021D8H        ;output port 0x05 value 0x04
..asm: 021D8H        LD    A,4
..asm: 021DAH        OUT0  (005H),A
transcoding to Z80: ;test13.j(14)   println(6);
transcoding to Z80: acc8= constant 6
..function: acc8Load
..asm: 021DDH        ;acc8= constant 6
..asm: 021DDH        LD    A,6
transcoding to Z80: call writeLineAcc8
..function: writeLineAcc8
..asm: 021DFH        ;call writeLineAcc8
..asm: 021DFH        CALL  writeLineA
transcoding to Z80: ;test13.j(15) 
transcoding to Z80: ;test13.j(16)   println("Klaar");
transcoding to Z80: acc16= constant 29
..function: acc16Load
..asm: 021E2H        ;acc16= constant 29
..asm: 021E2H        LD    HL,29
transcoding to Z80: writeLineString
..function: writeLineString
..asm: 021E5H        ;writeLineString
..asm: 021E5H        CALL  writeLineStr
transcoding to Z80: ;test13.j(17) }
transcoding to Z80: stop
..function: stop
..        JP    00171H      ;Jump to Zilog Z80183 Monitor.
..asm: 021E8H        ;stop
..asm: 021E8H        JP    00171H      ;Jump to Zilog Z80183 Monitor.
transcoding to Z80: stringConstant 0 = "Klaar"
Running compiled code ...

pc=    0 ;test13.j(0) /* Program to test generated Z80 assembler code */                  sp=   0 acc16=    0 acc8=  0 stack=[]
pc=    1 ;test13.j(1) class TestOutputInput {                                             sp=   0 acc16=    0 acc8=  0 stack=[]
pc=    2 ;test13.j(2)                                                                     sp=   0 acc16=    0 acc8=  0 stack=[]
pc=    3 ;test13.j(3)   println(0);                                                       sp=   0 acc16=    0 acc8=  0 stack=[]
pc=    4 acc8= constant 0                                                                 sp=   0 acc16=    0 acc8=  0 stack=[]
0
pc=    5 call writeLineAcc8                                                               sp=   0 acc16=    0 acc8=  0 stack=[]
pc=    6 ;test13.j(4)                                                                     sp=   0 acc16=    0 acc8=  0 stack=[]
pc=    7 ;test13.j(5)   // Possible operand types: constant, acc, var, stack8.            sp=   0 acc16=    0 acc8=  0 stack=[]
pc=    8 ;test13.j(6)                                                                     sp=   0 acc16=    0 acc8=  0 stack=[]
pc=    9 ;test13.j(7)   //constant + decimal constant                                     sp=   0 acc16=    0 acc8=  0 stack=[]
pc=   10 ;test13.j(8)   output(2, 1);                                                     sp=   0 acc16=    0 acc8=  0 stack=[]

output 0x01 to port 0x02pc=   11 output port 0x02 value 0x01                                                      sp=   0 acc16=    0 acc8=  0 stack=[]
pc=   12 ;test13.j(9)   println(3);                                                       sp=   0 acc16=    0 acc8=  0 stack=[]
pc=   13 acc8= constant 3                                                                 sp=   0 acc16=    0 acc8=  3 stack=[]
3
pc=   14 call writeLineAcc8                                                               sp=   0 acc16=    0 acc8=  3 stack=[]
pc=   15 ;test13.j(10)                                                                    sp=   0 acc16=    0 acc8=  3 stack=[]
pc=   16 ;test13.j(11)   //final variable + hexadecimal constant                          sp=   0 acc16=    0 acc8=  3 stack=[]
pc=   17 ;test13.j(12)   final byte port = 0x05;                                          sp=   0 acc16=    0 acc8=  3 stack=[]
pc=   18 ;test13.j(13)   output(port, 0x04);                                              sp=   0 acc16=    0 acc8=  3 stack=[]

output 0x04 to port 0x05pc=   19 output port 0x05 value 0x04                                                      sp=   0 acc16=    0 acc8=  3 stack=[]
pc=   20 ;test13.j(14)   println(6);                                                      sp=   0 acc16=    0 acc8=  3 stack=[]
pc=   21 acc8= constant 6                                                                 sp=   0 acc16=    0 acc8=  6 stack=[]
6
pc=   22 call writeLineAcc8                                                               sp=   0 acc16=    0 acc8=  6 stack=[]
pc=   23 ;test13.j(15)                                                                    sp=   0 acc16=    0 acc8=  6 stack=[]
pc=   24 ;test13.j(16)   println("Klaar");                                                sp=   0 acc16=    0 acc8=  6 stack=[]
pc=   25 acc16= constant 29                                                               sp=   0 acc16=   29 acc8=  6 stack=[]
Klaar
pc=   26 writeLineString                                                                  sp=   0 acc16=   29 acc8=  6 stack=[]
pc=   27 ;test13.j(17) }                                                                  sp=   0 acc16=   29 acc8=  6 stack=[]
pc=   28 stop                                                                             sp=   0 acc16=   29 acc8=  6 stack=[]
