import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;

/**
 * Compiler for the miniJava programming language.
 * Inspired by the book Compiler Engineering Using Pascal by P.C. Capon and P.J. Jinks
 * and of course Java as developed by Sun.
 *
 * Java style end of line comment.
 * Java style multi-line comment.
 * Multi-line may contain end of line comment.
 * Multi-line comment may not be nested.
 * All variables are 16 bit integers.
 *
 * program        = "class" identifier "{" statements "}".
 * identifier     = "(_A-Za-z)(_A-Za-z0-9)+".
 * statements     = (statement)*.
 * statement      = assignment | writeStatement | ifStatement | whileStatement.
 * assignment     = ["int"] identifier "=" expression ";".
 * writeStatement = "write" "(" expression ")" ";".
 * ifStatement    = "if" "(" comparison ")" block [ "else" block].
 * whileStatement = "while" "(" comparison ")" block.
 * block          = statement | "{" statements "}".
 * comparison     = expression relop expression.
 * expression     = term {addop term}.
 * term           = factor {mulop factor}.
 * factor         = identifier | constant | "read" | "(" expression ")".
 * addop          = "+" | "-".
 * mulop          = "*" | "/".
 * relop          = "==" | "!=" | ">" | ">=" | "<" | "<=".
 * constant       = "(0-9)*".
 */
public class Compiler {

  /* global variables used by the constructor or the interface functions */
  private static boolean debugMode;
  private static boolean verboseMode;
  private static String fileName;
  private BufferedReader input;
  private ArrayList<Instruction> storeInstruction = new ArrayList<Instruction>();

  //constructor
  public Compiler(boolean debugMode, boolean verboseMode) {
    this.debugMode = debugMode;
    this.verboseMode = verboseMode;
  }
  
  /* Class member methods for lexical analysis phase */
  public ArrayList<Instruction> compile(String fileName, BufferedReader input) throws IOException {
    if (verboseMode) System.out.println("debugMode = " + debugMode);

    this.fileName = fileName;
    this.input = input;
    try {
      init();
      prog();
      plant(new Instruction(FunctionType.stop));
    } catch (FatalError e) {
      error(e.getErrorNumber());
      System.exit(1);
    }
    
    if (errors != 0) { 
      storeInstruction.clear();
      codePos = 0;
    }
    if (verboseMode || (errors != 0) ) {
      System.out.println();
      System.out.print(errors);
      if (errors == 1) {
        System.out.println(" error.");
      } else {
        System.out.println(" errors.");
      }
    }
    return storeInstruction;
  }
  
  private void debug(String message) {
    if (debugMode) {
      System.out.print(message);
    }
  }

  /* 
   * variable containing the branch instructions known by the M machine as generated by the P language.
   * variable used during the code generation phase.
   */
  public EnumSet<FunctionType> brFunctions = EnumSet.of(
    FunctionType.br
    , FunctionType.brEq
    , FunctionType.brNe
    , FunctionType.brLt
    , FunctionType.brLe
    , FunctionType.brGt
    , FunctionType.brGe
    );

  /* Constants and class member variables for lexical analysis phase */
  private static final int MAX_LINE_WIDTH = 128;
  private static final int MAX_IDENTIFIER_LENGTH = MAX_LINE_WIDTH;
  private static final int MAX_CONSTANT = 65535; //16 bit constant
  private static final String VALID_IDENTIFIER_CHARACTERS ="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_";
  private String line;
  private int lineNumber;
  private int lastLinePrinted;
  private int lineSize;
  private int linePos;
  private ArrayList<String> sourceCode;
  private Lexeme lexeme, firstLexeme, lastLexeme;
  private Map<String, LexemeType> keywords = new HashMap<String, LexemeType>();
  private int errors;

  /* Constants and class member variables for syntax analysis phase */
  EnumSet<LexemeType> startExp = EnumSet.noneOf(LexemeType.class);
  EnumSet<LexemeType> startStatement = EnumSet.noneOf(LexemeType.class);

  /* Constants and class member variables for semantic analysis phase */
  private Identifiers identifiers = new Identifiers();
 
  /* Constants and class member variables for code generation phase */
  private static final int NULL_OP = 0;
  private static final int MAX_M_CODE = 512;
  private boolean accInUse;

  private Map<AddValType, FunctionType> forwardAdd = new HashMap<AddValType, FunctionType>();
  private Map<AddValType, FunctionType> reverseAdd = new HashMap<AddValType, FunctionType>();
  private Map<MulValType, FunctionType> forwardMul = new HashMap<MulValType, FunctionType>();
  private Map<MulValType, FunctionType> reverseMul = new HashMap<MulValType, FunctionType>();
  private Map<RelValType, FunctionType> normalSkip = new HashMap<RelValType, FunctionType>();
  private Map<RelValType, FunctionType> reverseSkip = new HashMap<RelValType, FunctionType>();

  private int codePos; /* position to plant next instruction */

  /*Class member methods for all phases */
  private void init() {
    /* initialisation of lexical analysis variables */
    lineNumber = 0;
    lineSize = 0;
    linePos = 0;
    sourceCode = new ArrayList<String>();
    errors = 0;
    firstLexeme = new Lexeme(LexemeType.constant);
    lexeme = new Lexeme(LexemeType.unknown);
    lastLexeme = new Lexeme(LexemeType.unknown);
    keywords.clear();
    for (LexemeType lexemeType = LexemeType.beginlexeme; lexemeType != LexemeType.unknown; lexemeType = lexemeType.next()) {
      keywords.put(lexemeType.getValue(), lexemeType);
    }


    /* initialisation of syntax analysis variables */
    startStatement.clear();
    startStatement.add(LexemeType.intlexeme);
    startStatement.add(LexemeType.identifier);
    startStatement.add(LexemeType.writelexeme);
    startStatement.add(LexemeType.iflexeme);
    startStatement.add(LexemeType.whilelexeme);
    startExp.clear();
    startExp.add(LexemeType.lbracket);
    startExp.add(LexemeType.identifier);
    startExp.add(LexemeType.constant);
    startExp.add(LexemeType.readlexeme);

    /* initialisation of semantic analysis variables */
    identifiers.init();

    /* initialisation of code generation variables */
    accInUse = false;
    codePos = 0;
    forwardAdd.clear();
    reverseAdd.clear();
    forwardMul.clear();
    reverseMul.clear();
    normalSkip.clear();
    reverseSkip.clear();
    storeInstruction.clear();

    forwardAdd.put(AddValType.add, FunctionType.accPlus);
    forwardAdd.put(AddValType.sub, FunctionType.accMinus);
    reverseAdd.put(AddValType.add, FunctionType.accPlus);
    reverseAdd.put(AddValType.sub, FunctionType.minusAcc);

    forwardMul.put(MulValType.muld, FunctionType.accTimes);
    forwardMul.put(MulValType.divd, FunctionType.accDiv);
    reverseMul.put(MulValType.muld, FunctionType.accTimes);
    reverseMul.put(MulValType.divd, FunctionType.divAcc);

    normalSkip.put(RelValType.eq, FunctionType.brNe);
    normalSkip.put(RelValType.ne, FunctionType.brEq);
    normalSkip.put(RelValType.gt, FunctionType.brLe);
    normalSkip.put(RelValType.lt, FunctionType.brGe);
    normalSkip.put(RelValType.ge, FunctionType.brLt);
    normalSkip.put(RelValType.le, FunctionType.brGt);
    reverseSkip.put(RelValType.eq, FunctionType.brNe);
    reverseSkip.put(RelValType.ne, FunctionType.brEq);
    reverseSkip.put(RelValType.gt, FunctionType.brGe);
    reverseSkip.put(RelValType.lt, FunctionType.brLe);
    reverseSkip.put(RelValType.ge, FunctionType.brGt);
    reverseSkip.put(RelValType.le, FunctionType.brLt);
  }
  
  private void error() {
    errors++;
    if (lastLinePrinted != lineNumber) {
      //when in debug mode, make sure error message starts at a new line
      if (debugMode) System.out.println();
      System.out.println(fileName + ":" + lineNumber);
      System.out.print(line); //when line of source code was read, it was extended with a linefeed.
      lastLinePrinted = lineNumber;
    }
    for (int i=0; i<linePos-1; i++) {
      System.out.print(' ');
    }
    System.out.print('^');
  }
  
  private void error(int n) {
    error();
    switch (n) {
      case 0 : System.out.println("error opening file " + fileName);break;
      case 1 : System.out.println("end of input encountered");break;
      case 2 : System.out.println("line too long; max width=" + MAX_LINE_WIDTH);break;
      case 3 : System.out.print("unexpected symbol;");break;
      case 4 : System.out.println("unknown character");break;
      case 5 : System.out.println("'=' expected after '=' or '!' ");break;
      case 6 : System.out.print("unknown keyword : ");break;
      case 7 : System.out.println("lexeme skipped after error");break;
      case 8 : System.out.println("variable already declared");break;
      case 9 : System.out.println("variable not declared");break;
      case 10 : System.out.println("code overflow");break;
      case 11 : System.out.println("lexemetype is null");break;
      case 12 : System.out.println("internal compiler error during code generation");break;
      case 13 : System.out.println("constant too big"); break;
    }
  }
  
  private void getLexeme() throws IOException, FatalError {
    char ch;
    //ignore white space and comments
    ch = getChar();
    while (ch == ' ' || ch == '\t' || ch == '\n' || (ch == '/' && (nextChar() == '*' || nextChar() == '/'))) {
      if (ch == '/' && nextChar() == '*') {
        ch = getChar();
        ch = getChar();
        while (ch != '*' || nextChar() != '/') {
          ch = getChar();
        }
        ch = getChar();
      } else if (ch == '/' && nextChar() == '/') {
        ch = getChar();
        while (nextChar() != '\n') {
          ch = getChar();
        }
      }
      ch = getChar();
    }
    if (ch >= '0' && ch <= '9') {
      /* try to recognise a constant */
      lexeme.type = LexemeType.constant;
      lexeme.constVal = (int)ch - (int)'0';
      boolean noError = true;
      while (nextChar() >= '0' && nextChar() <= '9' && noError) {
        ch = getChar();
        lexeme.constVal = lexeme.constVal * 10 + ((int)ch - (int)'0');
        //assumption: lexeme.constVal can be larger than MAX_CONSTANT.
        if (lexeme.constVal > MAX_CONSTANT) {
          noError = false;
        }
      }
      if (!noError) {
        /* constant too big */
        error(13);
        /* eat up remainder of constant */
        while (ch >= '0' && ch <= '9') {
          ch = getChar();
        }
      }
    } else if (ch == '{') {
      lexeme.type = LexemeType.beginlexeme;
    } else if (ch == '}') {
      lexeme.type = LexemeType.endlexeme;
    }else if (VALID_IDENTIFIER_CHARACTERS.contains("" + ch)){
      /* try to recognise an identifier or a keyword */
      String name = String.valueOf(ch);
      int charno = 0;
      while ( VALID_IDENTIFIER_CHARACTERS.contains("" + nextChar()) && charno <= MAX_IDENTIFIER_LENGTH) {
        if (charno <= MAX_IDENTIFIER_LENGTH) {
          name += String.valueOf(getChar());
          charno++;
        } else {
          ch = getChar();
        }
      }
      /* separate identifiers from keywords */
      LexemeType keyword = keywords.get(name);
      if (keyword == null) {
        lexeme.type = LexemeType.identifier;
      }
      else {
        lexeme.type = keyword;
      }
      lexeme.idVal = name;
    } else {
      /* try to recognise keywords  or , ; = ( ) + - * / <!=> */
      switch (ch) {
//        case '.' : lexeme.type = LexemeType.dot; break;
        case ',' : lexeme.type = LexemeType.comma; break;
        case ';' : lexeme.type = LexemeType.semicolon; break;
        case '(' : lexeme.type = LexemeType.lbracket; break;
        case ')' : lexeme.type = LexemeType.rbracket; break;
        case '+' :
          lexeme.type = LexemeType.addop;
          lexeme.addVal = AddValType.add;
          break;
        case '-' :
          lexeme.type = LexemeType.addop;
          lexeme.addVal = AddValType.sub;
          break;
        case '*' :
          lexeme.type = LexemeType.mulop;
          lexeme.mulVal = MulValType.muld;
          break;
        case '/' :
          lexeme.type = LexemeType.mulop;
          lexeme.mulVal = MulValType.divd;
          break;
        case '=' :
          if (nextChar() == '=') {
            ch = getChar();
            lexeme.type = LexemeType.relop;
            lexeme.relVal = RelValType.eq;
          } else {
            //TODO positive identification of assignment using valid characters after = symbol
            lexeme.type = LexemeType.assign;
            //error(5); /* = not followed by = */
          }
          break;
        case '!' :
          if (nextChar() == '=') {
            ch = getChar();
            lexeme.type = LexemeType.relop;
            lexeme.relVal = RelValType.ne;
          } else {
            lexeme.type = LexemeType.unknown;
            error(5); /* ! not followed by = */
          }
          break;
        case '>' :
          lexeme.type = LexemeType.relop;
          if (nextChar() == '=') {
            ch = getChar();
            lexeme.relVal = RelValType.ge;
          } else {
            lexeme.relVal = RelValType.gt;
          }
          break;
        case '<' :
          lexeme.type = LexemeType.relop;
          if (nextChar() == '=') {
            ch = getChar();
            lexeme.relVal = RelValType.le;
          } else {
            lexeme.relVal = RelValType.lt;
          }
          break;
        default :
          lexeme.type = LexemeType.unknown;
          error(4); /* unknown characters */
      }
    }
    debug("\ngetLexeme: " + lexeme.makeString(identifiers.getId(lexeme.idVal)));
  }

  private char getChar() throws IOException, FatalError {
    char result = nextChar();
    linePos++;
    return result;
  }
  
  private char nextChar() throws IOException, FatalError {
    if (linePos >= lineSize) {
      line = input.readLine();
      
      if (line == null) {
        throw new FatalError(1); //end of file encountered
      };
      
      //when in debug mode, make sure the echoed source code starts on a new line.
      debug("\n");
      debug(line);
      sourceCode.add(line);
      
      lineSize = line.length();
      if (lineSize > MAX_LINE_WIDTH) {
        throw new FatalError(2); //line too long
      }
      line += "\n";
      lineSize++;
      lineNumber++;
      linePos = 0;
    }
    return line.charAt(linePos);
  }
  
  /*Class member methods for syntax analysis phase */
  private boolean checkOrSkip(EnumSet<LexemeType> okSet, EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\ncheckOrSkip: start");
    boolean orFlag = false;
    boolean result = false;
    if (okSet.contains(lexeme.type)) {
      debug("\ncheckOrSkip: lexeme \"" + lexeme.type + "\" in okSet " + okSet);
      result = true;
    } else {
      error(3); /* okset expected */
      System.out.println(" found " + lexeme.type + ", expected " + okSet);
      if (stopSet.size() > 0) {
        while (!stopSet.contains(lexeme.type)) {
          error(7); /* lexeme skipped after error */
          getLexeme();
        }
      }
    }
    debug("\ncheckOrSkip: end");
    return result;
  }
  
  private Operand factor(EnumSet<LexemeType> stopSet, Operand operand) throws IOException, FatalError {
    operand.opType = OperandType.stack;
    if (checkOrSkip(startExp, stopSet)) {
      if (lexeme.type == LexemeType.identifier) {
        /* part of semantic analysis */
        if (!identifiers.checkId(lexeme.idVal)) error(9); /* variable not declared */
        /* part of code generation */
        operand.opType = OperandType.var;
        operand.opValue = identifiers.getId(lexeme.idVal);
        /* part of lexical analysis */
        getLexeme();
      } else if (lexeme.type == LexemeType.constant) {
        /* part of code generation */
        operand.opType = OperandType.constant;
        operand.opValue = lexeme.constVal;
        /* part of lexical analysis */
        getLexeme();
      } else if (lexeme.type == LexemeType.lbracket) {
        getLexeme();
        EnumSet<LexemeType> stopSetCopy = stopSet.clone();
        stopSetCopy.add(LexemeType.rbracket);
        operand = expression(stopSetCopy, operand);
        if (checkOrSkip(EnumSet.of(LexemeType.rbracket), stopSet)) {
          getLexeme();
        }
      } else if (lexeme.type == LexemeType.readlexeme) {
        getLexeme();
        /* part of code generation */
        if (accInUse) {
          plant(new Instruction(FunctionType.accStore, operand));
        }
        plant(new Instruction(FunctionType.read));
        accInUse = true;
      }
    }
    return operand;
  }
  
  private Operand term(EnumSet<LexemeType> stopSet, Operand operand) throws IOException, FatalError {
    /* part of code generation */
    MulValType operator;
    Operand rOperand = new Operand(null, null);

    /* part of lexical analysis */
    EnumSet<LexemeType> followSet = stopSet.clone();
    followSet.add(LexemeType.mulop);
    operand = factor(followSet, operand);
    while (lexeme.type == LexemeType.mulop) {
      /* part of code generation */
      plantAccLoad(operand);
      operand.opType = OperandType.stack;
      operator = lexeme.mulVal;
      /* part of lexical analysis */
      getLexeme();
      rOperand = factor(followSet, rOperand);
      /* part of code generation */
      if (rOperand.opType == OperandType.stack) {
        plant(new Instruction(reverseMul.get(operator), rOperand));
      } else {
        plant(new Instruction(forwardMul.get(operator), rOperand));
      }
    }
    return operand;
  }
  
  private Operand expression(EnumSet<LexemeType> stopSet, Operand operand) throws IOException, FatalError {
    debug("\nexpression: start with stopSet = " + stopSet);
    /* part of lexical analysis */
    AddValType operator;
    Operand rOperand = new Operand(null, null);
    
    /* part of lexical analysis */
    EnumSet<LexemeType> followSet = stopSet.clone();
    followSet.add(LexemeType.addop);
    operand = term(followSet, operand);
    while (lexeme.type == LexemeType.addop) {
      /* part of code generation */
      plantAccLoad(operand);
      operand.opType = OperandType.stack;
      operator = lexeme.addVal;
      
      /* part of lexical analysis */
      getLexeme();
      rOperand = term(followSet, rOperand);
      
      /* part of code generation */
      if (rOperand.opType == OperandType.stack) {
        plant(new Instruction(reverseAdd.get(operator), rOperand));
      } else {
        plant(new Instruction(forwardAdd.get(operator), rOperand));
      }
    }
    debug("\nexpression: end");
    return operand;
  }
  
  /**
  * returns address of if label
  **/
  private int comparison(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    /* part of code generation */
    RelValType compareOp;
    int ifLabel;
    /* part of lexical analysis */
    EnumSet<LexemeType> localSet = stopSet.clone();
    localSet.add(LexemeType.relop);
    Operand leftOperand = expression(localSet, new Operand(null, null));

    /* part of code generation */
    plantAccLoad(leftOperand);

    /* part of lexical analysis */
    localSet = stopSet.clone();
    localSet.addAll(startExp);
    if (checkOrSkip(EnumSet.of(LexemeType.relop), localSet)) {
      /* part of code generation */
      compareOp = lexeme.relVal;
      /* part of lexical analysis */
      getLexeme();
    } else {
      /* part of code generation */
      compareOp = RelValType.eq;
    }
    
    /* part of lexical analysis */
    localSet = stopSet.clone();
    localSet.addAll(startStatement);
    localSet.remove(LexemeType.identifier);
    Operand rightOperand = expression(localSet, new Operand(null, null));

    /* part of code generation */
    plant(new Instruction(FunctionType.accCompare, rightOperand));
    ifLabel = saveForwardLabel();
    Operand labelOperand = new Operand(OperandType.label, 0);
    if (rightOperand.opType != OperandType.stack) {
      plant(new Instruction(normalSkip.get(compareOp), labelOperand));
    } else {
      plant(new Instruction(reverseSkip.get(compareOp), labelOperand));
    }
    return ifLabel;
  }
  
  // block = statement | "{" statements "}".
  private void block(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\nblock: start with stopSet = " + stopSet);

    EnumSet<LexemeType> startSet = stopSet.clone();
    startSet.addAll(startStatement);
    startSet.add(LexemeType.beginlexeme);

    EnumSet<LexemeType> stopBlockSet = startSet.clone();
    stopBlockSet.add(LexemeType.semicolon);
    stopBlockSet.add(LexemeType.endlexeme);

    checkOrSkip(startSet, stopBlockSet);
    if (lexeme.type == LexemeType.beginlexeme) {
      getLexeme();
      statements(EnumSet.of(LexemeType.endlexeme));
      if (checkOrSkip(EnumSet.of(LexemeType.endlexeme), EnumSet.noneOf(LexemeType.class))) {
		  getLexeme();
	  }
    } else {
      statement(stopSet);
    }
    debug("\nblock: end");
  }

  //whileStatement = "while" "(" comparison ")" block.
  private void whileStatement(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\nwhileStatement: start with stopSet = " + stopSet);
    getLexeme();

    /* part of code generation */
    int whileLabel = saveLabel();

    /* part of lexical analysis */
    EnumSet<LexemeType> stopWhileSet = stopSet.clone();
    stopWhileSet.add(LexemeType.rbracket);
    if (checkOrSkip(EnumSet.of(LexemeType.lbracket), stopWhileSet)) {
      getLexeme();
    }

    /* part of lexical analysis */
    /* TODO the following 2 lines are redundant. */
    stopWhileSet = stopSet.clone();
    stopWhileSet.add(LexemeType.rbracket);
    stopWhileSet.addAll(startStatement);
    stopWhileSet.remove(LexemeType.identifier);
    int endLabel = comparison(stopWhileSet);
    
    stopWhileSet = stopSet.clone();
    stopWhileSet.addAll(startStatement);
    if (checkOrSkip(EnumSet.of(LexemeType.rbracket), stopWhileSet)) {
      getLexeme();
    }
    block(stopSet);
    
    /* part of code generation */
    plant(new Instruction(FunctionType.br, new Operand(OperandType.label, whileLabel)));
    plantForwardLabel(endLabel);
    debug("\nwhileStatement: end");
  }

  // ifStatement = "if" "(" comparison ")" block [ "else" block ].
  private void ifStatement(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\nifStatement: start with stopSet = " + stopSet);

    getLexeme();
    
    //expect (
    EnumSet<LexemeType> stopSetIf = stopSet.clone();
    stopSetIf.add(LexemeType.rbracket);
    if (checkOrSkip(EnumSet.of(LexemeType.lbracket), stopSetIf)) {
      getLexeme();
    }

    //expect comparison
    stopSetIf = stopSet.clone();
    stopSetIf.add(LexemeType.rbracket);
    stopSetIf.addAll(startStatement);
    stopSetIf.remove(LexemeType.identifier);
    int ifLabel = comparison(stopSetIf);
    
    //expect )
    stopSetIf = stopSet.clone();
    stopSetIf.addAll(startStatement);
    if (checkOrSkip(EnumSet.of(LexemeType.rbracket), stopSetIf)) {
      getLexeme();
    }

    //expect statement block
    EnumSet<LexemeType> stopSetElse = stopSet.clone();
    stopSetElse.add(LexemeType.elselexeme);
    block(stopSetElse);

    if (lexeme.type == LexemeType.elselexeme) {
      //expect else
      checkOrSkip(EnumSet.of(LexemeType.elselexeme), stopSetElse);

      /* part of code generation */
      int elseLabel = saveLabel();
      plant(new Instruction(FunctionType.br, new Operand(OperandType.label, 0)));
      plantForwardLabel(ifLabel);

      /* part of lexical analysis */
      //expect statement block
      getLexeme();
      block(stopSet);
      
      /* part of code generation */
      plantForwardLabel(elseLabel);
    } else {
      /* part of code generation */
      plantForwardLabel(ifLabel);
    }
	debug("\nifStatement: end");
  }

 //assignment = ["int"] identifier "=" expression ";".
  private void assignment(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\nassignment: start with stopSet = " + stopSet);

    EnumSet<LexemeType> stopAssignmentSet = stopSet.clone();
    stopAssignmentSet.addAll(startExp);
    stopAssignmentSet.add(LexemeType.semicolon);

    if (lexeme.type == LexemeType.intlexeme) {
      /* part of lexical analysis */
      getLexeme();
      if (checkOrSkip(EnumSet.of(LexemeType.identifier), stopAssignmentSet)) {

      // next line + debug message is part of semantic analysis.
        if (identifiers.declareId(lexeme.idVal)) {
          debug("\nassignment: var declared: " + lexeme.makeString(identifiers.getId(lexeme.idVal)));
        } else {
          error();
          System.out.println("variable already declared");
        }
      }
    }

    /* part of semantic analysis */
    if (!identifiers.checkId(lexeme.idVal)) {
      error();
      System.out.println("variable not declared: " + lexeme.idVal);
    }

    /* part of code generation */
    int assignTo = identifiers.getId(lexeme.idVal);

    /* part of lexical analysis */
    getLexeme();
    if (checkOrSkip(EnumSet.of(LexemeType.assign), stopAssignmentSet)) {
      getLexeme();
    }
    Operand operand = expression(stopSet, new Operand(null, null));
    if (checkOrSkip(EnumSet.of(LexemeType.semicolon), stopSet)) {
      getLexeme();
    }

    /* part of code generation */
    plantAccLoad(operand);
    plant(new Instruction(FunctionType.accStore, new Operand(OperandType.var, assignTo)));

    debug("\nassignment: end");
  }

  // writeStatement = "write" "(" expression ")" ";".
  private void writeStatement(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\nwriteStatement: start with stopSet = " + stopSet);
    getLexeme();

    EnumSet<LexemeType> stopWriteSet = stopSet.clone();
    stopWriteSet.addAll(startExp);
    stopWriteSet.add(LexemeType.rbracket);
    stopWriteSet.add(LexemeType.semicolon);
    if (checkOrSkip(EnumSet.of(LexemeType.lbracket), stopWriteSet)) {
      getLexeme();
    }
    
    EnumSet<LexemeType> stopExpressionSet = stopSet.clone();
    stopExpressionSet.add(LexemeType.rbracket);
    stopExpressionSet.add(LexemeType.semicolon);
    Operand operand = expression(stopExpressionSet, new Operand(null, null));
    
    /* part of lexical analysis */
    if (checkOrSkip(EnumSet.of(LexemeType.rbracket), stopExpressionSet)) {
      getLexeme();
    }

    if (checkOrSkip(EnumSet.of(LexemeType.semicolon), stopSet)) {
      getLexeme();
    }

    /* part of code generation */
    plantAccLoad(operand);
    plant(new Instruction(FunctionType.accStore, new Operand(OperandType.stack, 0)));
    plant(new Instruction(FunctionType.write));
    debug("\nwriteStatement: end");
  }

  //statement = assignment | writeStatement | ifStatement | whileStatement.
  private void statement(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\nstatement: start with stopSet = " + stopSet);
    /* part of code generation */
    accInUse = false;

    /* part of lexical analysis */
    EnumSet<LexemeType> startSet = stopSet.clone();
    startSet.addAll(startStatement);
    if (checkOrSkip(startSet, stopSet)) {
      if (lexeme.type == LexemeType.identifier || lexeme.type == LexemeType.intlexeme) {
        assignment(stopSet);
      } else if (lexeme.type == LexemeType.writelexeme) {
        writeStatement(stopSet);
      } else if (lexeme.type == LexemeType.iflexeme) {
        ifStatement(stopSet);
      } else if (lexeme.type == LexemeType.whilelexeme) {
        whileStatement(stopSet);
      }
    }
    debug("\nstatement: end");
  }
  
  //statements = (statement)*.
  private void statements(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\nstatements: start with stopSet = " + stopSet);
    
    //while (checkOrSkip(startStatement, stopSet)) {
    while (startStatement.contains(lexeme.type)) {
      statement(stopSet);
      //getLexeme();
    }
    debug("\nstatements: end");
  }
  
  //program = "class" identifier "{" statements "}".
  private void prog() throws IOException, FatalError {
    debug("\nprog: start");
    /* recognise a program */
    getLexeme();
    if (checkOrSkip(EnumSet.of(LexemeType.classlexeme), EnumSet.of(LexemeType.identifier, LexemeType.beginlexeme))) {
      getLexeme();
      if (checkOrSkip(EnumSet.of(LexemeType.identifier), EnumSet.of(LexemeType.beginlexeme))) {
        /* next line + debug message is part of semantic analysis */
        if (!identifiers.declareId(lexeme.idVal)) {
          error();
          System.out.println("identifier already declared");
        }
        debug("\nprog: class declared: " + lexeme.idVal);
        getLexeme();
        checkOrSkip(EnumSet.of(LexemeType.beginlexeme), EnumSet.noneOf(LexemeType.class));
        getLexeme();
        statements(EnumSet.of(LexemeType.endlexeme));
        //getLexeme();
        checkOrSkip(EnumSet.of(LexemeType.endlexeme), EnumSet.noneOf(LexemeType.class));
      }
    }
    debug("\nprog: end");
  }
  
  /*Class member methods for code generation phase */
  private void plantAccLoad(Operand operand) {
    if (operand.opType != OperandType.stack) {
      if (accInUse) {
          plant(new Instruction(FunctionType.stackAccLoad, operand));
        } else {
          plant(new Instruction(FunctionType.accLoad, operand));
      }
    }
    accInUse = true;
  }

  private void plant(Instruction instruction) {
    /* for debugging purposes */
    debug("\n->plant (accInUse=" + accInUse + "):");
    
    /* add original source code */
    if (!sourceCode.isEmpty()) {
      instruction.linesOfCode.addAll(sourceCode);
      sourceCode.clear();
    }

    /* insert M (virtual machine) code into memory */
    if (storeInstruction.size() >= MAX_M_CODE) {
      error (10);
      storeInstruction.clear();
    }
    storeInstruction.add(instruction);

    /* for debugging purposes */
    debug("\n" + String.format("%3d :", codePos) + instruction.toString());

    codePos++;
  };
  
  private void plantForwardLabel(int pos) {
    storeInstruction.get(pos).operand.opValue = storeInstruction.size();
    /* for debugging purposes */
    debug("\nlabel: used from " + pos);
  }

  private int saveForwardLabel() {
    /* for debugging purposes */
    debug("\nlabel used");

    return codePos;
  }

  private int saveLabel() {
    /* for debugging purposes */
    debug("\nlabel:");

    return codePos;
  }

}
