import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;

/**
 * Compiler for the P programming language, as described in Compiler Engineering Using Pascal by P.C. Capon and P.J. Jinks.
 *
 * program        = ["VAR" idlist] block ".".
 * idlist         = identifier {"," identifier} ";".
 * identifier     = "A-Z".
 * block          = statement | "BEGIN" block {";" block} "END".
 * statement      = assignment | writeStatement | ifStatement | whileStatement.
 * assignment     = identifier ":=" expression.
 * writeStatement = "WRITE" "(" expression ")".
 * ifStatement    = "IF" comparison "THEN" block.
 * whileStatement = "WHILE" comparison "DO" block.
 * comparison     = expression relop expression.
 * expression     = term {addop term}.
 * term           = factor {mulop factor}.
 * factor         = identifier | constant | "READ" | "(" expression ")".
 * addop          = "+" | "-".
 * mulop          = "*" | "/".
 * relop          = "<" | "<=" | "<>" | "=" | ">=" | ">".
 * constant       = "0-9".
 */
public class Compiler {

  /* global variables used by the constructor or the interface functions */
  private static boolean debug;
  private static boolean z80CodeGeneration;
  private static boolean binaryCodeGeneration;
  private static String fileName;
  private BufferedReader input;
  private ArrayList<Instruction> storeInstruction = new ArrayList<Instruction>();

  //constructor
  public Compiler(boolean debug, boolean z80, boolean binary) {
    this.debug = debug;
    this.z80CodeGeneration = z80;
    this.binaryCodeGeneration = binary;
  }
  
  /* Class member methods for lexical analysis phase */
  public ArrayList<Instruction> compile(String fileName, BufferedReader input) throws IOException {
    System.out.println("debug = " + debug);
    System.out.println("z80CodeGeneration = " + z80CodeGeneration);
    System.out.println("binaryCodeGeneration = " + binaryCodeGeneration);

    this.fileName = fileName;
    this.input = input;
    try {
      init();
      prog();
      plant(new Instruction(FunctionType.stop));
    } catch (FatalError e) {
      error(e.getErrorNumber());
      System.exit(1);
    }
    
    if (errors) { 
      storeInstruction.clear();
      codePos = 0;
    }
    return storeInstruction;
  }
  
  private void debug(String message) {
    if (debug) {
      System.out.print(message);
    }
  }

  /* 
   * variable containing the branch instructions known by the M machine as generated by the P language.
   * variable used during the code generation phase.
   */
  public EnumSet<FunctionType> brFunctions = EnumSet.of(
    FunctionType.br
    , FunctionType.brEq
    , FunctionType.brNe
    , FunctionType.brLt
    , FunctionType.brLe
    , FunctionType.brGt
    , FunctionType.brGe
    );

  /* Constants and class member variables for lexical analysis phase */
  private static final int LINE_WIDTH = 128;
  private static final int NAME_CHARS = 6;

  private boolean eof;
  private int lineSize;
  private int linePos;
  private String line;
  private Lexeme lexeme, firstLexeme, lastLexeme;
  private boolean errors;

  /* Constants and class member variables for syntax analysis phase */
  EnumSet<LexemeType> startExp = EnumSet.noneOf(LexemeType.class);
  EnumSet<LexemeType> startBlock = EnumSet.noneOf(LexemeType.class);
 
  /* Constants and class member variables for semantic analysis phase */
  /* variables: -1: not declared, >=0: memory address allocated */
  private Map<String, Integer> variables = new HashMap<String, Integer>();
  private int nextVariable;

  /* Constants and class member variables for code generation phase */
  private static final int NULL_OP = 0;
  private static final int MAX_M_CODE = 512;
  private static final int MAX_ASM_CODE = 2000;  /* max Z80 assembler lines of code */
  private static final int MIN_BIN = 2000; /* Z80 assembled bytes start at 2000 */
  private static final int MAX_BIN = 4000; /* max Z80 assembled bytes */
  private static final int MEM_START = 4000;
  private boolean accInUse;

  private Map<AddValType, FunctionType> forwardAdd = new HashMap<AddValType, FunctionType>();
  private Map<AddValType, FunctionType> reverseAdd = new HashMap<AddValType, FunctionType>();
  private Map<MulValType, FunctionType> forwardMul = new HashMap<MulValType, FunctionType>();
  private Map<MulValType, FunctionType> reverseMul = new HashMap<MulValType, FunctionType>();
  private Map<RelValType, FunctionType> normalSkip = new HashMap<RelValType, FunctionType>();
  private Map<RelValType, FunctionType> reverseSkip = new HashMap<RelValType, FunctionType>();

  private int codePos; /* position to plant next instruction */
  private int z80PosLine;
  private int z80PosByte;
  private String[] storeString;
  private int[] storeBytes;

  /*Class member methods for all phases */
  private void init() {
    /* initialisation of lexical analysis variables */
    eof = false;
    lineSize = 0;
    linePos = 0;
    errors = false;
    firstLexeme = new Lexeme(LexemeType.dot);
    lexeme = new Lexeme(LexemeType.unknown);
    lastLexeme = new Lexeme(LexemeType.unknown);

    /* initialisation of syntax analysis variables */
    startExp.clear();
    startExp.add(LexemeType.lbracket);
    startExp.add(LexemeType.identifier);
    startExp.add(LexemeType.constant);
    startExp.add(LexemeType.readlexeme);
    startBlock.clear();
    startBlock.add(LexemeType.beginlexeme);
    startBlock.add(LexemeType.identifier);
    startBlock.add(LexemeType.iflexeme);
    startBlock.add(LexemeType.whilelexeme);
    startBlock.add(LexemeType.writelexeme);

    /* initialisation of semantic analysis variables */
    nextVariable = 0;
    variables.clear();
    
    /* initialisation of code generation variables */
    accInUse = false;
    codePos = 0;
    forwardAdd.clear();
    reverseAdd.clear();
    forwardMul.clear();
    reverseMul.clear();
    normalSkip.clear();
    reverseSkip.clear();
    storeInstruction.clear();
    storeString = new String[MAX_ASM_CODE];
    storeBytes = new int[MAX_BIN];
    z80PosLine = 0;
    z80PosByte = MIN_BIN;

    forwardAdd.put(AddValType.add, FunctionType.accPlus);
    forwardAdd.put(AddValType.sub, FunctionType.accMinus);
    reverseAdd.put(AddValType.add, FunctionType.accPlus);
    reverseAdd.put(AddValType.sub, FunctionType.minusAcc);

    forwardMul.put(MulValType.muld, FunctionType.accTimes);
    forwardMul.put(MulValType.divd, FunctionType.accDiv);
    reverseMul.put(MulValType.muld, FunctionType.accTimes);
    reverseMul.put(MulValType.divd, FunctionType.divAcc);

    normalSkip.put(RelValType.eq, FunctionType.brNe);
    normalSkip.put(RelValType.ne, FunctionType.brEq);
    normalSkip.put(RelValType.gt, FunctionType.brLe);
    normalSkip.put(RelValType.lt, FunctionType.brGe);
    normalSkip.put(RelValType.ge, FunctionType.brLt);
    normalSkip.put(RelValType.le, FunctionType.brGt);
    reverseSkip.put(RelValType.eq, FunctionType.brNe);
    reverseSkip.put(RelValType.ne, FunctionType.brEq);
    reverseSkip.put(RelValType.gt, FunctionType.brGe);
    reverseSkip.put(RelValType.lt, FunctionType.brLe);
    reverseSkip.put(RelValType.ge, FunctionType.brGt);
    reverseSkip.put(RelValType.le, FunctionType.brLt);
  }
  
  private void error(int n) {
    System.out.print("\n");
    for (int i=0; i<linePos-1; i++) {
      System.out.print(' ');
    }
    System.out.print('^');
    switch (n) {
      case 0 : System.out.println("error opening file " + fileName);break;
      case 1 : System.out.println("end of input encountered");break;
      case 2 : System.out.println("line too long; max width=" + LINE_WIDTH);break;
      case 3 : System.out.println("unexpected symbol");break;
      case 4 : System.out.println("unknown character");break;
      case 5 : System.out.println("'=' expected after ':' ");break;
      case 6 : System.out.print("unknown keyword : ");break;
      case 7 : System.out.println("lexeme skipped after error");break;
      case 8 : System.out.println("variable already declared");break;
      case 9 : System.out.println("variable not declared");break;
      case 10 : System.out.println("code overflow");break;
      case 11 : System.out.println("lexemetype is null");break;
      case 12 : System.out.println("internal compiler error during code generation");break;
    }
  }
  
  private void getLexeme() throws IOException, FatalError {
    char ch;
    //ignore spaces and comments
    while (nextChar() == ' ' || nextChar() == '\t' || nextChar() == '\n' || nextChar() == '{') {
      ch = getChar();
      if (ch == '{') {
        while (getChar() != '}') {/*nothing*/}
      }
    }
    ch = getChar();
    if (ch >= '0' && ch <= '9') {
      /* try to recognise a constant */
      lexeme.type = LexemeType.constant;
      lexeme.constVal = (int)ch - (int)'0';
    } else if (ch >= 'A' && ch <= 'Z') {
      /* try to recognise an identifier or a keyword */
      if (nextChar() < 'A' || nextChar() > 'Z') {
        lexeme.type = LexemeType.identifier;
        lexeme.idVal = String.valueOf(ch);
      } else {
        /* try to recognise keywords read, write,if,then,var,begin or end */
        String name = String.valueOf(ch);
        int charno = 1;
        while (nextChar() >= 'A' && nextChar() <= 'Z' && charno <= NAME_CHARS) {
          if (charno <= NAME_CHARS) {
            name += String.valueOf(getChar());
            charno++;
          } else {
            ch = getChar();
          }
        }
        debug("\nlexeme: name=" + name);
        lexeme.type = LexemeType.beginlexeme;
        while (lexeme.type.ordinal() <= LexemeType.endlexeme.ordinal() && !lexeme.type.getValue().equals(name)) {
          lexeme.type = lexeme.type.next();
        }
        //if (lexeme.type.ordinal() > LexemeType.endlexeme.ordinal()) {
        if (!lexeme.type.getValue().equals(name)) {
          lexeme.type = LexemeType.unknown;
          error(6); /* unknown name */
          System.out.println(name);
        }
      }
    } else {
      /* try to recognise keywords  - , ; := ( ) + - * / <=> */
      switch (ch) {
        case '.' : lexeme.type = LexemeType.dot; break;
        case ',' : lexeme.type = LexemeType.comma; break;
        case ';' : lexeme.type = LexemeType.semicolon; break;
        case ':' :
          if (nextChar() == '=') {
            ch = getChar();
            lexeme.type = LexemeType.assign;
          } else {
            lexeme.type = LexemeType.unknown;
            error(5); /* : not followed by = */
          }
          break;
        case '(' : lexeme.type = LexemeType.lbracket; break;
        case ')' : lexeme.type = LexemeType.rbracket; break;
        case '+' :
          lexeme.type = LexemeType.addop;
          lexeme.addVal = AddValType.add;
          break;
        case '-' :
          lexeme.type = LexemeType.addop;
          lexeme.addVal = AddValType.sub;
          break;
        case '*' :
          lexeme.type = LexemeType.mulop;
          lexeme.mulVal = MulValType.muld;
          break;
        case '/' :
          lexeme.type = LexemeType.mulop;
          lexeme.mulVal = MulValType.divd;
          break;
        case '<' :
          lexeme.type = LexemeType.relop;
          ch = nextChar();
          if (nextChar() == '=') {
            ch = getChar();
            lexeme.relVal = RelValType.le;
          } else if (nextChar() == '>') {
            ch = getChar();
            lexeme.relVal = RelValType.ne;
          } else {
            lexeme.relVal = RelValType.lt;
          }
          break;
        case '=' :
          lexeme.type = LexemeType.relop;
          lexeme.relVal = RelValType.eq;
          break;
        case '>' :
          lexeme.type = LexemeType.relop;
          if (nextChar() == '=') {
            ch = getChar();
            lexeme.relVal = RelValType.ge;
          } else {
            lexeme.relVal = RelValType.gt;
          }
          break;
        default :
          lexeme.type = LexemeType.unknown;
          error(4); /* unknown characters */
      }
    }
    debug("\nlexeme=" + lexeme.makeString(variables));
  }

  private char getChar() throws IOException, FatalError {
    char result = nextChar();
    linePos++;
    return result;
  }
  
  private char nextChar() throws IOException, FatalError {
    if (linePos >= lineSize) {
      line = input.readLine();
      eof = (line == null);
      if (eof) {
        throw new FatalError(1); //end of file encountered
      };
      debug("\n"); //when in debug mode, make sure the echoed source code starts on a new line.
      System.out.println(line);
      line += "\n";
      lineSize = line.length();
      if (lineSize > LINE_WIDTH) {
        throw new FatalError(2); //line too long
      }
      linePos = 0;
    }
    return line.charAt(linePos);
  }
  
  /*Class member methods for syntax analysis phase */
  private boolean checkOrSkip(EnumSet<LexemeType> okSet, EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    //debug("\ncheckOrSkip: start");
    boolean orFlag = false;
    boolean result = false;
    if (okSet.contains(lexeme.type)) {
      debug("\ncheckOrSkip: lexeme \"" + lexeme.type + "\" in okSet " + okSet);
      result = true;
    } else {
      error(3); /* okset expected */
      for (LexemeType aLexeme: EnumSet.allOf(LexemeType.class).range(firstLexeme.type, lastLexeme.type)) {
        if (okSet.contains(aLexeme)) {
          if (orFlag) {
            debug(" or ");
          }
          orFlag = true;
          debug(aLexeme.getValue());
        }
      }
      debug(" expected.");
      if (stopSet.size() > 0) {
        while (!stopSet.contains(lexeme.type)) {
          error(7); /* lexeme skipped after error */
          getLexeme();
        }
      }
    }
    //debug("\ncheckOrSkip: end");
    return result;
  }
  
  private void idList(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\nidlist start");
    boolean cont;
    EnumSet<LexemeType> continueSet = EnumSet.of(LexemeType.comma, LexemeType.identifier);
    EnumSet<LexemeType> ignoreSet = EnumSet.of(LexemeType.semicolon, LexemeType.comma);
    EnumSet<LexemeType> followSet1 = stopSet.clone();
    followSet1.addAll(ignoreSet);
    EnumSet<LexemeType> followSet2 = stopSet.clone();
    followSet2.addAll(continueSet);
    
    do {
      if (checkOrSkip(EnumSet.of(LexemeType.identifier), followSet1)) {
        declareId(); /* part of semantic analysis */
        getLexeme();
      }
      debug("\nidlist var declared");
      checkOrSkip(ignoreSet, followSet2);
      debug("\nidlist ; or , ignored");
      cont = continueSet.contains(lexeme.type);
      if (lexeme.type == LexemeType.comma) {
        debug("\nidlist , skipped");
        getLexeme();
      }
    }
    while (cont);
    debug("\nidlist end of id list reached");

    if (lexeme.type == LexemeType.semicolon) {
      debug("\nidlist ; skipped");
      getLexeme();
    }

    debug("\nidlist end");
  }
  
  private Operand factor(EnumSet<LexemeType> stopSet, Operand operand) throws IOException, FatalError {
    operand.opType = OperandType.stack;
    if (checkOrSkip(startExp, stopSet)) {
      if (lexeme.type == LexemeType.identifier) {
        /* part of semantic analysis */
        checkId();
        /* part of code generation */
        operand.opType = OperandType.var;
        operand.opValue = variables.get(lexeme.idVal);
        /* part of lexical analysis */
        getLexeme();
      } else if (lexeme.type == LexemeType.constant) {
        /* part of code generation */
        operand.opType = OperandType.constant;
        operand.opValue = lexeme.constVal;
        /* part of lexical analysis */
        getLexeme();
      } else if (lexeme.type == LexemeType.lbracket) {
        getLexeme();
        EnumSet<LexemeType> stopSetCopy = stopSet.clone();
        stopSetCopy.add(LexemeType.rbracket);
        operand = expression(stopSetCopy, operand);
        if (checkOrSkip(EnumSet.of(LexemeType.rbracket), stopSet)) {
          getLexeme();
        }
      } else if (lexeme.type == LexemeType.readlexeme) {
        getLexeme();
        /* part of code generation */
        if (accInUse) {
          plant(new Instruction(FunctionType.accStore, OperandType.stack));
        }
        plant(new Instruction(FunctionType.call, CallType.read));
        accInUse = true;
      }
    }
    return operand;
  }
  
  private Operand term(EnumSet<LexemeType> stopSet, Operand operand) throws IOException, FatalError {
    /* part of code generation */
    MulValType operator;
    Operand rOperand = new Operand();

    /* part of lexical analysis */
    EnumSet<LexemeType> followSet = stopSet.clone();
    followSet.add(LexemeType.mulop);
    operand = factor(followSet, operand);
    while (lexeme.type == LexemeType.mulop) {
      /* part of code generation */
      plantAccLoad(operand);
      operand.opType = OperandType.stack;
      operator = lexeme.mulVal;
      /* part of lexical analysis */
      getLexeme();
      rOperand = factor(followSet, rOperand);
      /* part of code generation */
      if (rOperand.opType == OperandType.stack) {
        plant(new Instruction(reverseMul.get(operator), OperandType.stack));
      } else {
        plant(new Instruction(forwardMul.get(operator), rOperand.opType, rOperand.opValue));
      }
    }
    return operand;
  }
  
  private Operand expression(EnumSet<LexemeType> stopSet, Operand operand) throws IOException, FatalError {
    /* part of lexical analysis */
    AddValType operator;
    Operand rOperand = new Operand();
    /* part of lexical analysis */
    EnumSet<LexemeType> followSet = stopSet.clone();
    followSet.add(LexemeType.addop);
    operand = term(followSet, operand);
    while (lexeme.type == LexemeType.addop) {
      /* part of code generation */
      plantAccLoad(operand);
      operand.opType = OperandType.stack;
      operator = lexeme.addVal;
      /* part of lexical analysis */
      getLexeme();
      rOperand = term(followSet, rOperand);
      /* part of code generation */
      if (rOperand.opType == OperandType.stack) {
        plant(new Instruction(reverseAdd.get(operator), OperandType.stack));
      } else {
        plant(new Instruction(forwardAdd.get(operator), rOperand.opType, rOperand.opValue));
      }
    }
    return operand;
  }
  
  /**
  * returns address of if label
  **/
  private int comparison(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    /* part of code generation */
    RelValType compareOp;
    int ifLabel;
    /* part of lexical analysis */
    EnumSet<LexemeType> localSet = stopSet.clone();
    localSet.add(LexemeType.relop);
    Operand operand = expression(localSet, new Operand());

    /* part of code generation */
    plantAccLoad(operand);

    /* part of lexical analysis */
    localSet = stopSet.clone();
    localSet.addAll(startExp);
    if (checkOrSkip(EnumSet.of(LexemeType.relop), localSet)) {
      /* part of code generation */
      compareOp = lexeme.relVal;
      /* part of lexical analysis */
      getLexeme();
    } else {
      /* part of code generation */
      compareOp = RelValType.eq;
    }
    
    /* part of lexical analysis */
    localSet = stopSet.clone();
    localSet.addAll(startBlock);
    localSet.remove(LexemeType.identifier);
    operand = expression(localSet, operand);

    /* part of code generation */
    if (operand.opType != OperandType.stack) {
      plant(new Instruction(FunctionType.accCompare, operand.opType, operand.opValue));
      ifLabel = saveForwardLabel();
      plant(new Instruction(normalSkip.get(compareOp), 0));
    } else {
      plant(new Instruction(FunctionType.accCompare, OperandType.stack));
      ifLabel = saveForwardLabel();
      plant(new Instruction(reverseSkip.get(compareOp), 0));
    }
    return ifLabel;
  }
  
  private void statement(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\nstatement: start");
    /* part of code generation */
    Operand operand = new Operand();
    accInUse = false;

    /* part of lexical analysis */
    EnumSet<LexemeType> localSet = stopSet.clone();
    localSet.addAll(startBlock);
    if (checkOrSkip(localSet, stopSet)) {
      if (lexeme.type == LexemeType.identifier) {
        /* part of semantic analysis */
        checkId(); 
        /* part of code generation */
        int assignTo = variables.get(lexeme.idVal);
        /* part of lexical analysis */
        getLexeme();
        
        localSet = stopSet.clone();
        localSet.addAll(startExp);
        if (checkOrSkip(EnumSet.of(LexemeType.assign), localSet)) {
          getLexeme();
        }
        operand = expression(stopSet, operand);
        
        plantAccLoad(operand);
        plant(new Instruction(FunctionType.accStore, OperandType.var, assignTo));
      } else if (lexeme.type == LexemeType.iflexeme) {
        getLexeme();
        
        localSet = stopSet.clone();
        localSet.add(LexemeType.thenlexeme);
        localSet.addAll(startBlock);
        localSet.remove(LexemeType.identifier);
        int ifLabel = comparison(localSet);
        
        localSet = stopSet.clone();
        localSet.addAll(startBlock);
        if (checkOrSkip(EnumSet.of(LexemeType.thenlexeme), localSet)) {
          getLexeme();
        }
        block(stopSet);

        /* part of code generation */
        plantForwardLabel(ifLabel);
      } else if (lexeme.type == LexemeType.whilelexeme) {
        debug("\nstatement: start while loop");
        getLexeme();

        /* part of code generation */
        int whileLabel = saveLabel();

        /* part of lexical analysis */
        localSet = stopSet.clone();
        localSet.add(LexemeType.dolexeme);
        localSet.addAll(startBlock);
        localSet.remove(LexemeType.identifier);
        int ifLabel = comparison(localSet);
        
        localSet = stopSet.clone();
        localSet.addAll(startBlock);
        if (checkOrSkip(EnumSet.of(LexemeType.dolexeme), localSet)) {
          getLexeme();
        }
        block(stopSet);
        
        /* part of code generation */
        plant(new Instruction(FunctionType.br, whileLabel));
        plantForwardLabel(ifLabel);
        debug("\nstatement: end of while loop");
      } else if (lexeme.type == LexemeType.writelexeme) {
        getLexeme();

        localSet = stopSet.clone();
        localSet.add(LexemeType.rbracket);
        localSet.addAll(startExp);
        if (checkOrSkip(EnumSet.of(LexemeType.lbracket), localSet)) {
          getLexeme();
        }
        
        localSet = stopSet.clone();
        localSet.add(LexemeType.rbracket);
        operand = expression(localSet, operand);
        
        /* part of code generation */
        plantAccLoad(operand);

        /* part of lexical analysis */
        if (checkOrSkip(EnumSet.of(LexemeType.rbracket), stopSet)) {
          getLexeme();
        }

        /* part of code generation */
        plant(new Instruction(FunctionType.accStore, OperandType.stack));
        plant(new Instruction(FunctionType.call, CallType.write));
      }
    }
    debug("\nstatement: end");
  }
  
  private void block(EnumSet<LexemeType> stopSet) throws IOException, FatalError {
    debug("\nblock: start");
    EnumSet<LexemeType> stopOrStartSet = stopSet.clone();
    stopOrStartSet.addAll(startBlock);
    checkOrSkip(stopOrStartSet, stopOrStartSet);
    if (lexeme.type == LexemeType.beginlexeme) {
      getLexeme();
      
      EnumSet<LexemeType> semicolonOrEndSet = EnumSet.of(LexemeType.semicolon, LexemeType.endlexeme);
      EnumSet<LexemeType> blockSet = stopSet.clone();
      blockSet.addAll(semicolonOrEndSet);
      block(blockSet);
      
      stopOrStartSet.add(LexemeType.semicolon);
      checkOrSkip(semicolonOrEndSet, stopOrStartSet);
      
      EnumSet<LexemeType> startSet = startBlock.clone();
      startSet.add(LexemeType.semicolon);
      
      EnumSet<LexemeType> endOfBlockSet = stopSet.clone();
      endOfBlockSet.add(LexemeType.semicolon);
      endOfBlockSet.add(LexemeType.endlexeme);
      while (startSet.contains(lexeme.type)) {
        if (lexeme.type == LexemeType.semicolon) {
          getLexeme();
        }
        block(endOfBlockSet);
        checkOrSkip(semicolonOrEndSet, stopOrStartSet);
      }
      if (lexeme.type == LexemeType.endlexeme) {
        getLexeme();
      }
    } else {
      statement(stopSet);
    }
    debug("\nblock: end");
  }
  
  private void prog() throws IOException, FatalError {
    debug("\nprog start");
    /* recognise a program */
    getLexeme();
    if (lexeme.type == LexemeType.varlexeme) {
      getLexeme();
      idList(EnumSet.of(LexemeType.beginlexeme, LexemeType.semicolon, LexemeType.dot));
    }
    do {
      block(EnumSet.of(LexemeType.dot));
    } while (!checkOrSkip(EnumSet.of(LexemeType.dot), EnumSet.noneOf(LexemeType.class)));
    debug("\nprog end");
  }
  
  /*Class member methods for semantic analysis phase */
  private void declareId() {
    if (variables.get(lexeme.idVal) != null) {
      error(8); /* variable already declared */
    } else {
      variables.put(lexeme.idVal, nextVariable);
      nextVariable++;
      debug("\n" + lexeme.makeString(variables));
    }
  }
  
  private void checkId() {
    Integer varAddress = variables.get(lexeme.idVal);
    if ((varAddress != null) && (varAddress == -1)) {
      error(9); /* variable not declared */
      variables.put(lexeme.idVal, -1); /* prevent further error messages */
    }
  }

  /*Class member methods for code generation phase */
  private void plantAccLoad(Operand operand) {
    if (operand.opType != OperandType.stack) {
      if (accInUse) {
          plant(new Instruction(FunctionType.stackAccLoad, operand.opType, operand.opValue));
        } else {
          plant(new Instruction(FunctionType.accLoad, operand.opType, operand.opValue));
      }
    }
    accInUse = true;
  }

  private void plant(Instruction instruction) {
    /* for debugging purposes */
    debug("\n->plant (accInUse=" + accInUse + "):");

    if (z80CodeGeneration && !binaryCodeGeneration) {
      /* Z80 code generation */
      plantZ80(instruction);
    } else if (z80CodeGeneration && binaryCodeGeneration) {
      /* Z80 code generation */
      plantZ80Bin(instruction);
    } else {
      /* M (virtual machine) code generation */
      plantM(instruction);
    }
  }

  private void plantM(Instruction instruction) {
    /* insert code into memory */
    if (storeInstruction.size() >= MAX_M_CODE) {
      error (10);
      storeInstruction.clear();
    }
    storeInstruction.add(instruction);

    /* for debugging purposes */
    debug("\n" + String.format("%3d :", codePos) + instruction.toString());

    codePos++;
  };
  
  private void plantZ80(Instruction instruction) {
    if (z80PosLine >= MAX_ASM_CODE) {
      error (10);
      z80PosLine = 0;
    }
    
    if (z80PosLine == 0) {
      plantZ80Runtime();
    }

    FunctionType function = instruction.function;
    OperandType opType = instruction.opType;
    CallType callValue = instruction.callValue;
    int word = instruction.word;
    int memAddress = MEM_START + word * 2;

    if (function == FunctionType.stop) {
      storeString[z80PosLine++] = "HALT";
    } else if (function == FunctionType.call) {
      if (callValue == CallType.read) {
        storeString[z80PosLine++] = "CALL read";
      } else if (callValue == CallType.write) {
        storeString[z80PosLine++] = "CALL write";
      } else {
        storeString[z80PosLine++] = String.format("CALL 0x%04X", word);
      }
    } else if (brFunctions.contains(function)) {
      if (function == FunctionType.br) {
        storeString[z80PosLine++] = String.format("JP L" + word);
      } else if (function == FunctionType.brEq) {
        storeString[z80PosLine++] = String.format("JP Z,L" + word);
      } else if (function == FunctionType.brNe) {
        storeString[z80PosLine++] = String.format("JP NZ,L" + word);
      } else if (function == FunctionType.brLt) {
        storeString[z80PosLine++] = String.format("JP NC,L" + word);
      } else if (function == FunctionType.brLe) {
        storeString[z80PosLine++] = String.format("JP NC,L" + word);
        storeString[z80PosLine++] = String.format("JP Z,L" + word);
      } else if (function == FunctionType.brGt) {
        storeString[z80PosLine++] = "JR   Z,$+5";
        storeString[z80PosLine++] = String.format("JP C,L" + word);
      } else if (function == FunctionType.brGe) {
        storeString[z80PosLine++] = String.format("JP C,L" + word);
      }
    } else if (function == FunctionType.accLoad) {
      switch(opType) {
        case var: 
          storeString[z80PosLine++] = "LD   HL,(" + memAddress + ")";
          break;
        case constant: 
          storeString[z80PosLine++] = "LD   HL," + word;
          break;
        case stack:
          storeString[z80PosLine++] = "POP HL";
          break;
      };
    } else if (function == FunctionType.accStore) {
      switch(opType) {
        case var: 
          storeString[z80PosLine++] = "LD   (" + memAddress + "),HL";
          break;
        case stack:
          storeString[z80PosLine++] = "PUSH HL";
          break;
      };
    } else if (function == FunctionType.stackAccLoad) {
      storeString[z80PosLine++] = "PUSH HL";
      switch(opType) {
        case var: 
          storeString[z80PosLine++] = "LD   HL,(" + memAddress + ")";
          break;
        case constant: 
          storeString[z80PosLine++] = "LD   HL," + word;
          break;
      };
    } else if (function == FunctionType.accPlus) {
      switch(opType) {
        case var: 
          storeString[z80PosLine++] = "LD   DE,(" + memAddress + ")";
          break;
        case constant: 
          storeString[z80PosLine++] = "LD   DE," + word;
          break;
        case stack:
          storeString[z80PosLine++] = "POP DE";
          break;
      };
      storeString[z80PosLine++] = "ADD   HL,DE";
    } else if ((function == FunctionType.accMinus) || (function == FunctionType.minusAcc) || (function == FunctionType.accCompare)) {
      switch(opType) {
        case var: 
          storeString[z80PosLine++] = "LD   DE,(" + memAddress + ")";
          break;
        case constant: 
          storeString[z80PosLine++] = "LD   DE," + word;
          break;
        case stack:
          storeString[z80PosLine++] = "POP DE";
          break;
      };
      if (function == FunctionType.accCompare) {
        storeString[z80PosLine++] = "PUSH  HL";
      }
      if (function == FunctionType.minusAcc) {
        storeString[z80PosLine++] = "EX    DE,HL";
      }
      storeString[z80PosLine++] = "SCF";
      storeString[z80PosLine++] = "CCF";
      storeString[z80PosLine++] = "SBC   HL,DE";
      if (function == FunctionType.accCompare) {
        storeString[z80PosLine++] = "POP   HL";
      }
    } else if (function == FunctionType.accTimes) {
      switch(opType) {
        case var: 
          storeString[z80PosLine++] = "LD   DE,(" + memAddress + ")";
          break;
        case constant: 
          storeString[z80PosLine++] = "LD   DE," + word;
          break;
        case stack:
          storeString[z80PosLine++] = "POP DE";
          break;
      };
      storeString[z80PosLine++] = "CALL mul16";
    } else if ((function == FunctionType.accDiv) || (function == FunctionType.divAcc)) {
      switch(opType) {
        case var: 
          storeString[z80PosLine++] = "LD   DE,(" + memAddress + ")";
          break;
        case constant: 
          storeString[z80PosLine++] = "LD   DE," + word;
          break;
        case stack:
          storeString[z80PosLine++] = "POP DE";
          break;
      };
      if (function == FunctionType.divAcc) {
        storeString[z80PosLine++] = "EX    DE,HL";
      }
      storeString[z80PosLine++] = "CALL div16";
    }
  }
  
  private void plantZ80Runtime() {
      storeString[z80PosLine++] = "JP main";

      storeString[z80PosLine++] = "mul16:";
      /* DEHL = HL * DE */
      storeString[z80PosLine++] = "push bc";
      storeString[z80PosLine++] = "ld b,h";
      storeString[z80PosLine++] = "ld c,l";
      storeString[z80PosLine++] = "ld hl,0";
      storeString[z80PosLine++] = "ld a,16";
      storeString[z80PosLine++] = "mul16_1:";
      storeString[z80PosLine++] = "add hl,hl";
      storeString[z80PosLine++] = "rl e";
      storeString[z80PosLine++] = "rl d";
      storeString[z80PosLine++] = "jr nc,mul16_2";
      storeString[z80PosLine++] = "add hl,bc";
      storeString[z80PosLine++] = "jr nc, mul16_2";
      storeString[z80PosLine++] = "inc de";
      storeString[z80PosLine++] = "mul16_2:";
      storeString[z80PosLine++] = "dec a";
      storeString[z80PosLine++] = "jr nz, mul16_1";
      storeString[z80PosLine++] = "pop bc";
      storeString[z80PosLine++] = "ret";

      storeString[z80PosLine++] = "div16:";
      /* teller in HL; deler in DE -> quotient in HL; restant in DE */
      storeString[z80PosLine++] = "LD   A,D"; /* als DE=0, error div by zero */
      storeString[z80PosLine++] = "OR   E";
      storeString[z80PosLine++] = "JR   Z,ERROR";
      storeString[z80PosLine++] = "LD   B,H"; /* kopie teller in BC */
      storeString[z80PosLine++] = "LD   C,L";
      storeString[z80PosLine++] = "LD   HL,0"; /* result = 0 */
      storeString[z80PosLine++] = "LD   A,B"; /* deler High */
      storeString[z80PosLine++] = "LD   B,16D";
      storeString[z80PosLine++] = "TRIALSB:";
      storeString[z80PosLine++] = "RL   C"; /* roteer links result + ACC */
      storeString[z80PosLine++] = "RLA";
      storeString[z80PosLine++] = "ADC  HL,HL"; /* schuif links; carry wordt niet beïnvloed */
      storeString[z80PosLine++] = "SBC  HL,DE"; /* teller eraftrekken */
      storeString[z80PosLine++] = "NULL:";
      storeString[z80PosLine++] = "CCF"; /* result bit */
      storeString[z80PosLine++] = "JR   NC,NGV"; /* Acc negatief? */
      storeString[z80PosLine++] = "PTV:";
      storeString[z80PosLine++] = "DJNZ TRIALSB";
      storeString[z80PosLine++] = "JP   DONE";
      storeString[z80PosLine++] = "RESTOR:";
      storeString[z80PosLine++] = "RL   C"; /* roteer links result + acc */
      storeString[z80PosLine++] = "RLA";
      storeString[z80PosLine++] = "ADC  HL,HL"; /* schuif links; carry wordt niet beïnvloed */
      storeString[z80PosLine++] = "AND  A"; /* carry op nul zetten */
      storeString[z80PosLine++] = "ADC  HL,DE"; /* herstel door deler erbij te tellen */
      storeString[z80PosLine++] = "JR   C,PTV"; /* resultaat positief */
      storeString[z80PosLine++] = "JR   Z,NULL"; /* resultaat nul */
      storeString[z80PosLine++] = "NGV:";
      storeString[z80PosLine++] = "DJNZ RESTOR";
      storeString[z80PosLine++] = "DONE:";
      storeString[z80PosLine++] = "RL   C"; /* resultaat bit inschuiven */
      storeString[z80PosLine++] = "RLA";
      storeString[z80PosLine++] = "LD   B,A"; /* quotient in BC */
      storeString[z80PosLine++] = "LD   A,H"; /* restant High negatief? */
      storeString[z80PosLine++] = "OR   A";
      storeString[z80PosLine++] = "JP   P,PREM";
      storeString[z80PosLine++] = "ADD  HL,DE"; /* corrigeer negatief restant */
      storeString[z80PosLine++] = "PREM:";
      storeString[z80PosLine++] = "RET";
      /*
This divides DE by BC, storing the result in DE, remainder in HL

DE_Div_BC:          ;1281-2x, x is at most 16
     ld a,16        ;7
     ld hl,0        ;10
     jp $+5         ;10
DivLoop:
       add hl,bc    ;--
       dec a        ;64
       ret z        ;86
       sla e        ;128
       rl d         ;128
       adc hl,hl    ;240
       sbc hl,bc    ;240
       jr nc,DivLoop ;23|21
       inc e        ;--
       jp DivLoop+1
       */

       storeString[z80PosLine++] = "main:";
  }
  
  private void plantZ80Bin(Instruction instruction) {
    if (codePos >= MAX_BIN) {
      error (10);
      codePos = MIN_BIN;
    }
    
    FunctionType function = instruction.function;
    OperandType opType = instruction.opType;
    CallType callValue = instruction.callValue;
    int word = instruction.word;
    int memAddress = MEM_START + word * 2;

    if (function == FunctionType.stop) {
      storeBytes[z80PosByte++] = 0xC3; /* JP 0x0171 */
      storeBytes[z80PosByte++] = 0x71;
      storeBytes[z80PosByte++] = 0x01;
    } else if (function == FunctionType.call) {
      storeBytes[z80PosByte++] = 0xCD; /* CALL */
      if (callValue == CallType.read) {
        storeBytes[z80PosByte++] = 0x03;
        storeBytes[z80PosByte++] = 0x00;
      } else if (callValue == CallType.write) {
        storeBytes[z80PosByte++] = 0x06;
        storeBytes[z80PosByte++] = 0x00;
      } else {
        storeBytes[z80PosByte++] = word % 256;
        storeBytes[z80PosByte++] = word / 256;
      }
    } else if (brFunctions.contains(function)) {
      if (function == FunctionType.br) {
        storeBytes[z80PosByte++] = 0xC3; /* JP nnnn*/
      } else if (function == FunctionType.brEq) {
        storeBytes[z80PosByte++] = 0xCA; /* JP   Z,nnnn */
      } else if (function == FunctionType.brNe) {
        storeBytes[z80PosByte++] = 0xC2; /* JP   NZ,nnnn */
      } else if (function == FunctionType.brLt) {
        storeBytes[z80PosByte++] = 0xD2; /* JP   NC,nnnn */
      } else if (function == FunctionType.brLe) {
        storeBytes[z80PosByte++] = 0xD2; /* JP   NC,nnnn */
        storeBytes[z80PosByte++] = word % 256;
        storeBytes[z80PosByte++] = word / 256;
        storeBytes[z80PosByte++] = 0xCA; /* JP   Z,nnnn */
      } else if (function == FunctionType.brGt) {
        storeBytes[z80PosByte++] = 0x28; /* JR   Z,$+5 */
        storeBytes[z80PosByte++] = 3;
        storeBytes[z80PosByte++] = 0xDA; /* JP   C,nnnn */
      } else if (function == FunctionType.brGe) {
        storeBytes[z80PosByte++] = 0xDA; /* JP   C,nnnn */
      }
      storeBytes[z80PosByte++] = word / 256;
      storeBytes[z80PosByte++] = word % 256;
    } else if (function == FunctionType.accLoad) {
      switch(opType) {
        case var: 
          storeBytes[z80PosByte++] = 0x2A; /* LD   HL,(memAddress) */
          storeBytes[z80PosByte++] = memAddress % 256;
          storeBytes[z80PosByte++] = memAddress / 256;
          break;
        case constant: 
          storeBytes[z80PosByte++] = 0x21; /* LD   HL,word */
          storeBytes[z80PosByte++] = word % 256;
          storeBytes[z80PosByte++] = word / 256;
          break;
        case stack:
          storeBytes[z80PosByte++] = 0xE1; /* POP HL */
          break;
      };
    } else if (function == FunctionType.accStore) {
      switch(opType) {
        case var: 
          storeBytes[z80PosByte++] = 0x22; /* LD   (memAddress),HL */
          storeBytes[z80PosByte++] = memAddress % 256;
          storeBytes[z80PosByte++] = memAddress / 256;
          break;
        case stack:
          storeBytes[z80PosByte++] = 0xE5; /* PUSH HL */
          break;
      };
    } else if (function == FunctionType.stackAccLoad) {
      storeBytes[z80PosByte++] = 0xE5; /* PUSH HL */
      switch(opType) {
        case var: 
          storeBytes[z80PosByte++] = 0x2A; /* LD   HL,(" + memAddress + ") */
          storeBytes[z80PosByte++] = memAddress % 256;
          storeBytes[z80PosByte++] = memAddress / 256;
          break;
        case constant: 
          storeBytes[z80PosByte++] = 0x21; /* LD   HL,word; */
          storeBytes[z80PosByte++] = word % 256;
          storeBytes[z80PosByte++] = word / 256;
          break;
      };
    } else if (function == FunctionType.accPlus) {
      switch(opType) {
        case var: 
          storeBytes[z80PosByte++] = 0xED; /* LD   DE,(memAddress) */
          storeBytes[z80PosByte++] = 0x5B;
          storeBytes[z80PosByte++] = memAddress % 256;
          storeBytes[z80PosByte++] = memAddress / 256;
          break;
        case constant: 
          storeBytes[z80PosByte++] = 0x11; /* LD   DE,word */
          storeBytes[z80PosByte++] = word % 256;
          storeBytes[z80PosByte++] = word / 256;
          break;
        case stack:
          storeBytes[z80PosByte++] = 0xD1; /* POP DE */
          break;
      };
      storeBytes[z80PosByte++] = 0x19; /* ADD   HL,DE */
    } else if ((function == FunctionType.accMinus) || (function == FunctionType.minusAcc) || (function == FunctionType.accCompare)) {
      switch(opType) {
        case var: 
          storeBytes[z80PosByte++] = 0xED; /* LD   DE,(memAddress) */
          storeBytes[z80PosByte++] = 0x5B;
          storeBytes[z80PosByte++] = memAddress % 256;
          storeBytes[z80PosByte++] = memAddress / 256;
          break;
        case constant: 
          storeBytes[z80PosByte++] = 0x11; /* LD   DE,word */
          storeBytes[z80PosByte++] = word % 256;
          storeBytes[z80PosByte++] = word / 256;
          break;
        case stack:
          storeBytes[z80PosByte++] = 0xD1; /* POP DE */
          break;
      };
      if (function == FunctionType.accCompare) {
        storeBytes[z80PosByte++] = 0xE5; /* PUSH  HL */
      }
      if (function == FunctionType.minusAcc) {
        storeBytes[z80PosByte++] = 0xEB; /* EX    DE,HL */
      }
      storeBytes[z80PosByte++] = 0x37; /* SCF */
      storeBytes[z80PosByte++] = 0x3F; /* CCF */
      storeBytes[z80PosByte++] = 0xED; /* SBC   HL,DE */
      storeBytes[z80PosByte++] = 0x52;
      if (function == FunctionType.accCompare) {
        storeBytes[z80PosByte++] = 0xE1; /* POP   HL */
      }
    } else if (function == FunctionType.accTimes) {
      switch(opType) {
        case var: 
          storeBytes[z80PosByte++] = 0xED; /* LD   DE,(memAddress) */
          storeBytes[z80PosByte++] = 0x5B;
          storeBytes[z80PosByte++] = memAddress % 256;
          storeBytes[z80PosByte++] = memAddress / 256;
          break;
        case constant: 
          storeBytes[z80PosByte++] = 0x11; /* LD   DE,word */
          storeBytes[z80PosByte++] = word % 256;
          storeBytes[z80PosByte++] = word / 256;
          break;
        case stack:
          storeBytes[z80PosByte++] = 0xD1; /* POP DE */
          break;
      };
      /* HL := HL * DE
              H  L
              D  E
          --------*
                EL
             EH  0
             DL  0
          DH  0  0
       -----------+
        P  Q  R  S
       S=ELlow
       R=ELhigh+EHlow+DLlow
       Q=DHlow+EHhigh+DLhigh
       P=DHhigh
      */

      storeBytes[z80PosByte++] = 0x63; /* LD   H,E */
      storeBytes[z80PosByte++] = 0xED; /* MLT  HL */
      storeBytes[z80PosByte++] = 0x6C;
      /*
DE_Times_BC:
;Inputs:
;     DE and HL are factors
;Outputs:
;     A is 0
;     BC is not changed
;     DEHL is the product
;
  push bc
  ld b,h
  ld c,l
  ld hl,0
  ld a,16
Mul_Loop_1:
  add hl,hl
  rl e
  rl d
  jr nc,Mul_Loop_2
    add hl,bc
    jr nc,Mul_Loop_2
    inc de
Mul_Loop_2:
  dec a
  jr nz,Mul_Loop_1
  pop bc
  ret
       */
    } else if ((function == FunctionType.accDiv) || (function == FunctionType.divAcc)) {
      switch(opType) {
        case var: 
          storeBytes[z80PosByte++] = 0xED; /* LD   DE,(memAddress) */
          storeBytes[z80PosByte++] = 0x5B;
          storeBytes[z80PosByte++] = memAddress % 256;
          storeBytes[z80PosByte++] = memAddress / 256;
          break;
        case constant: 
          storeBytes[z80PosByte++] = 0x11;  /* LD   DE,word */
          storeBytes[z80PosByte++] = word % 256;
          storeBytes[z80PosByte++] = word / 256;
          break;
        case stack:
          storeBytes[z80PosByte++] = 0xD1; /* POP DE */
          break;
      };
      if (function == FunctionType.divAcc) {
        storeBytes[z80PosByte++] = 0xEB; /* EX    DE,HL */
      }
      /* teller in HL; deler in DE -> quotient in HL; restant in DE */
      /* LD   A,D */ /* als DE=0, error div by zero */
      /* OR   E */
      /* JR   Z,ERROR */
      /* LD   B,H */ /* kopie teller in BC */
      /* LD   C,L */
      /* LD   HL,0 */ /* result = 0 */
      /* LD   A,B */ /* deler High */
      /* LD   B,16D */
      /* TRIALSB: */
      /* RL   C */ /* roteer links result + ACC */
      /* RLA */
      /* ADC  HL,HL */ /* schuif links; carry wordt niet beïnvloed */
      /* SBC  HL,DE */ /* teller eraftrekken */
      /* NULL: */
      /* CCF */ /* result bit */
      /* JR   NC,NGV */ /* Acc negatief? */
      /* PTV: */
      /* DJNZ TRIALSB */
      /* JP   DONE */
      /* RESTOR: */
      /* RL   C */ /* roteer links result + acc */
      /* RLA */
      /* ADC  HL,HL */ /* schuif links; carry wordt niet beïnvloed */
      /* AND  A */ /* carry op nul zetten */
      /* ADC  HL,DE */ /* herstel door deler erbij te tellen */
      /* JR   C,PTV */ /* resultaat positief */
      /* JR   Z,NULL */ /* resultaat nul */
      /* NGV: */
      /* DJNZ RESTOR */
      /* DONE: */
      /* RL   C */ /* resultaat bit inschuiven */
      /* RLA */
      /* LD   B,A */ /* quotient in BC */
      /* LD   A,H */ /* restant High negatief? */
      /* OR   A */
      /* JP   P,PREM */
      /* ADD  HL,DE */ /* corrigeer negatief restant */
      /* PREM: */
      /* RET */
      storeBytes[z80PosByte++] = 0x00;
      /*
This divides DE by BC, storing the result in DE, remainder in HL

DE_Div_BC:          ;1281-2x, x is at most 16
     ld a,16        ;7
     ld hl,0        ;10
     jp $+5         ;10
DivLoop:
       add hl,bc    ;--
       dec a        ;64
       ret z        ;86
       sla e        ;128
       rl d         ;128
       adc hl,hl    ;240
       sbc hl,bc    ;240
       jr nc,DivLoop ;23|21
       inc e        ;--
       jp DivLoop+1
       */
    }
  }
  
  private void plantForwardLabel(int pos) {
    if (z80CodeGeneration && !binaryCodeGeneration) {
      /* Z80 code generation */
      storeString[z80PosLine] = "L" + z80PosLine + ":";
      storeString[pos] = storeString[pos].replace("L0", "L" + z80PosLine);
      z80PosLine++;
    } else if (z80CodeGeneration && binaryCodeGeneration) {
      /* Z80 code generation */
      storeBytes[pos+1] = z80PosByte % 256;
      storeBytes[pos+2] = z80PosByte / 256;
    } else {
      /* M (virtual machine) code generation */
      //TODO remove commented line
      //storeInstruction[pos].word = codePos;
      storeInstruction.get(pos).word = storeInstruction.size();
    }
    /* for debugging purposes */
    debug("\nlabel: used from " + pos);
  }

  private int saveForwardLabel() {
    /* for debugging purposes */
    debug("\nlabel used");

    int result = 0;
    if (z80CodeGeneration && !binaryCodeGeneration) {
      /* Z80 code generation */
      result = z80PosLine;
    } else if (z80CodeGeneration && binaryCodeGeneration) {
      /* Z80 code generation */
      result = z80PosByte;
    } else {
      /* M (virtual machine) code generation */
      result = codePos;
    }
    return result;
  }

  private int saveLabel() {
    /* for debugging purposes */
    debug("\nlabel:");

    int result = 0;
    if (z80CodeGeneration && !binaryCodeGeneration) {
      /* Z80 code generation */
      result = z80PosLine;
      storeString[z80PosLine] = "L" + z80PosLine + ":";
      z80PosLine++;
    } else if (z80CodeGeneration && binaryCodeGeneration) {
      /* Z80 code generation */
      result = z80PosByte;
    } else {
      /* M (virtual machine) code generation */
      result = codePos;
    }
    return result;
  }

}
