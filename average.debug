
prog: start
/*
 * A small program in the miniJava language.
 * Boek: Rachel Kushner: Club mars.
 */
class Average {
getLexeme: class
checkOrSkip: start
checkOrSkip: lexeme "classlexeme" in okSet [classlexeme]
checkOrSkip: end
getLexeme: identifier Average
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [identifier]
checkOrSkip: end
prog: class declared: Average
getLexeme: {
checkOrSkip: start
checkOrSkip: lexeme "beginlexeme" in okSet [beginlexeme]
checkOrSkip: end
  int sum := 0;
getLexeme: int
statements: start with stopSet = [endlexeme]
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "intlexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
assignment: start with stopSet = [endlexeme]
getLexeme: identifier sum
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [identifier]
checkOrSkip: end
assignment: var declared: identifier sum@1
getLexeme: :=
checkOrSkip: start
checkOrSkip: lexeme "assign" in okSet [assign]
checkOrSkip: end
getLexeme: constant 0
expression: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: ;
expression: end
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
  int NUMBER_OF_NUMBERS := 0;
getLexeme: int
->plant (accInUse=false):
  0 :acc= constant 0
->plant (accInUse=true):
  1 :acc=> variable 1
assignment: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "intlexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
assignment: start with stopSet = [endlexeme]
getLexeme: identifier NUMBER_OF_NUMBERS
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [identifier]
checkOrSkip: end
assignment: var declared: identifier NUMBER_OF_NUMBERS@2
getLexeme: :=
checkOrSkip: start
checkOrSkip: lexeme "assign" in okSet [assign]
checkOrSkip: end
getLexeme: constant 0
expression: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: ;
expression: end
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
  //read a new number and echo number to output
  int number := read; 
getLexeme: int
->plant (accInUse=false):
  2 :acc= constant 0
->plant (accInUse=true):
  3 :acc=> variable 2
assignment: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "intlexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
assignment: start with stopSet = [endlexeme]
getLexeme: identifier number
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [identifier]
checkOrSkip: end
assignment: var declared: identifier number@3
getLexeme: :=
checkOrSkip: start
checkOrSkip: lexeme "assign" in okSet [assign]
checkOrSkip: end
getLexeme: read
expression: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "readlexeme" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: ;
->plant (accInUse=false):
  4 :call read
expression: end
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
  write(number);
getLexeme: write
->plant (accInUse=true):
  5 :acc=> variable 3
assignment: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "writelexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
writeStatement: start with stopSet = [endlexeme]
getLexeme: (
checkOrSkip: start
checkOrSkip: lexeme "lbracket" in okSet [lbracket]
checkOrSkip: end
getLexeme: identifier number@3
expression: start with stopSet = [semicolon, rbracket, endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: )
expression: end
checkOrSkip: start
checkOrSkip: lexeme "rbracket" in okSet [rbracket]
checkOrSkip: end
getLexeme: ;
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
  while (number <> 0) /* not end of file */ {
getLexeme: while
->plant (accInUse=false):
  6 :acc= variable 3
->plant (accInUse=true):
  7 :acc=> stack
->plant (accInUse=true):
  8 :call write
writeStatement: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "whilelexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
whileStatement: start with stopSet = [endlexeme]
getLexeme: (
label:
checkOrSkip: start
checkOrSkip: lexeme "lbracket" in okSet [lbracket]
checkOrSkip: end
getLexeme: identifier number@3
expression: start with stopSet = [rbracket, relop, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: <=> ne
expression: end
->plant (accInUse=false):
  9 :acc= variable 3
checkOrSkip: start
checkOrSkip: lexeme "relop" in okSet [relop]
checkOrSkip: end
getLexeme: constant 0
expression: start with stopSet = [rbracket, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: )
expression: end
->plant (accInUse=true):
 10 :accom constant 0
label used
->plant (accInUse=true):
 11 :breq 0
checkOrSkip: start
checkOrSkip: lexeme "rbracket" in okSet [rbracket]
checkOrSkip: end
getLexeme: {
block: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "beginlexeme" in okSet [identifier, beginlexeme, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
    sum := sum + number;
getLexeme: identifier sum@1
statements: start with stopSet = [endlexeme]
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
assignment: start with stopSet = [endlexeme]
getLexeme: :=
checkOrSkip: start
checkOrSkip: lexeme "assign" in okSet [assign]
checkOrSkip: end
getLexeme: identifier sum@1
expression: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: + or - add
->plant (accInUse=false):
 12 :acc= variable 1
getLexeme: identifier number@3
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: ;
->plant (accInUse=true):
 13 :acc+ variable 3
expression: end
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
    NUMBER_OF_NUMBERS := NUMBER_OF_NUMBERS + 1;
getLexeme: identifier NUMBER_OF_NUMBERS@2
->plant (accInUse=true):
 14 :acc=> variable 1
assignment: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
assignment: start with stopSet = [endlexeme]
getLexeme: :=
checkOrSkip: start
checkOrSkip: lexeme "assign" in okSet [assign]
checkOrSkip: end
getLexeme: identifier NUMBER_OF_NUMBERS@2
expression: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: + or - add
->plant (accInUse=false):
 15 :acc= variable 2
getLexeme: constant 1
checkOrSkip: start
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: ;
->plant (accInUse=true):
 16 :acc+ constant 1
expression: end
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
    //read a new number and echo number to output
    number := read;
getLexeme: identifier number@3
->plant (accInUse=true):
 17 :acc=> variable 2
assignment: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
assignment: start with stopSet = [endlexeme]
getLexeme: :=
checkOrSkip: start
checkOrSkip: lexeme "assign" in okSet [assign]
checkOrSkip: end
getLexeme: read
expression: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "readlexeme" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: ;
->plant (accInUse=false):
 18 :call read
expression: end
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
    write(number);
getLexeme: write
->plant (accInUse=true):
 19 :acc=> variable 3
assignment: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "writelexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
writeStatement: start with stopSet = [endlexeme]
getLexeme: (
checkOrSkip: start
checkOrSkip: lexeme "lbracket" in okSet [lbracket]
checkOrSkip: end
getLexeme: identifier number@3
expression: start with stopSet = [semicolon, rbracket, endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: )
expression: end
checkOrSkip: start
checkOrSkip: lexeme "rbracket" in okSet [rbracket]
checkOrSkip: end
getLexeme: ;
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
  }
getLexeme: }
->plant (accInUse=false):
 20 :acc= variable 3
->plant (accInUse=true):
 21 :acc=> stack
->plant (accInUse=true):
 22 :call write
writeStatement: end
statement: end
statements: end
checkOrSkip: start
checkOrSkip: lexeme "endlexeme" in okSet [endlexeme]
checkOrSkip: end
  /* multi line comment
   * with nested // end of line comment
   * is allowed.
   */
  write(NUMBER_OF_NUMBERS);
getLexeme: write
block: end
->plant (accInUse=true):
 23 :br 9
label: used from 11
whileStatement: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "writelexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
writeStatement: start with stopSet = [endlexeme]
getLexeme: (
checkOrSkip: start
checkOrSkip: lexeme "lbracket" in okSet [lbracket]
checkOrSkip: end
getLexeme: identifier NUMBER_OF_NUMBERS@2
expression: start with stopSet = [semicolon, rbracket, endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: )
expression: end
checkOrSkip: start
checkOrSkip: lexeme "rbracket" in okSet [rbracket]
checkOrSkip: end
getLexeme: ;
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
  write(sum);
getLexeme: write
->plant (accInUse=false):
 24 :acc= variable 2
->plant (accInUse=true):
 25 :acc=> stack
->plant (accInUse=true):
 26 :call write
writeStatement: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "writelexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
writeStatement: start with stopSet = [endlexeme]
getLexeme: (
checkOrSkip: start
checkOrSkip: lexeme "lbracket" in okSet [lbracket]
checkOrSkip: end
getLexeme: identifier sum@1
expression: start with stopSet = [semicolon, rbracket, endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: )
expression: end
checkOrSkip: start
checkOrSkip: lexeme "rbracket" in okSet [rbracket]
checkOrSkip: end
getLexeme: ;
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
  int average := 99;
getLexeme: int
->plant (accInUse=false):
 27 :acc= variable 1
->plant (accInUse=true):
 28 :acc=> stack
->plant (accInUse=true):
 29 :call write
writeStatement: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "intlexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
assignment: start with stopSet = [endlexeme]
getLexeme: identifier average
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [identifier]
checkOrSkip: end
assignment: var declared: identifier average@4
getLexeme: :=
checkOrSkip: start
checkOrSkip: lexeme "assign" in okSet [assign]
checkOrSkip: end
getLexeme: constant 99
expression: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: ;
expression: end
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
  if (NUMBER_OF_NUMBERS <> 0) {
getLexeme: if
->plant (accInUse=false):
 30 :acc= constant 99
->plant (accInUse=true):
 31 :acc=> variable 4
assignment: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "iflexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
ifStatement: start with stopSet = [endlexeme]
getLexeme: (
checkOrSkip: start
checkOrSkip: lexeme "lbracket" in okSet [lbracket]
checkOrSkip: end
getLexeme: identifier NUMBER_OF_NUMBERS@2
expression: start with stopSet = [rbracket, relop, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: <=> ne
expression: end
->plant (accInUse=false):
 32 :acc= variable 2
checkOrSkip: start
checkOrSkip: lexeme "relop" in okSet [relop]
checkOrSkip: end
getLexeme: constant 0
expression: start with stopSet = [rbracket, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: )
expression: end
->plant (accInUse=true):
 33 :accom constant 0
label used
->plant (accInUse=true):
 34 :breq 0
checkOrSkip: start
checkOrSkip: lexeme "rbracket" in okSet [rbracket]
checkOrSkip: end
getLexeme: {
block: start with stopSet = [elselexeme, endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "beginlexeme" in okSet [identifier, beginlexeme, writelexeme, intlexeme, iflexeme, elselexeme, whilelexeme, endlexeme]
checkOrSkip: end
    average := sum / NUMBER_OF_NUMBERS;
getLexeme: identifier average@4
statements: start with stopSet = [endlexeme]
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
assignment: start with stopSet = [endlexeme]
getLexeme: :=
checkOrSkip: start
checkOrSkip: lexeme "assign" in okSet [assign]
checkOrSkip: end
getLexeme: identifier sum@1
expression: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: * or / divd
->plant (accInUse=false):
 35 :acc= variable 1
getLexeme: identifier NUMBER_OF_NUMBERS@2
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: ;
->plant (accInUse=true):
 36 :acc/ variable 2
expression: end
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
  } else {
getLexeme: }
->plant (accInUse=true):
 37 :acc=> variable 4
assignment: end
statement: end
statements: end
checkOrSkip: start
checkOrSkip: lexeme "endlexeme" in okSet [endlexeme]
checkOrSkip: end
getLexeme: else
block: end
checkOrSkip: start
checkOrSkip: lexeme "elselexeme" in okSet [elselexeme]
checkOrSkip: end
label:
->plant (accInUse=true):
 38 :br 0
label: used from 34
getLexeme: {
block: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "beginlexeme" in okSet [identifier, beginlexeme, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
    average := 0;
getLexeme: identifier average@4
statements: start with stopSet = [endlexeme]
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
assignment: start with stopSet = [endlexeme]
getLexeme: :=
checkOrSkip: start
checkOrSkip: lexeme "assign" in okSet [assign]
checkOrSkip: end
getLexeme: constant 0
expression: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: ;
expression: end
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
  }
getLexeme: }
->plant (accInUse=false):
 39 :acc= constant 0
->plant (accInUse=true):
 40 :acc=> variable 4
assignment: end
statement: end
statements: end
checkOrSkip: start
checkOrSkip: lexeme "endlexeme" in okSet [endlexeme]
checkOrSkip: end
  write(average);
getLexeme: write
block: end
label: used from 38
ifStatement: end
statement: end
statement: start with stopSet = [endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "writelexeme" in okSet [identifier, writelexeme, intlexeme, iflexeme, whilelexeme, endlexeme]
checkOrSkip: end
writeStatement: start with stopSet = [endlexeme]
getLexeme: (
checkOrSkip: start
checkOrSkip: lexeme "lbracket" in okSet [lbracket]
checkOrSkip: end
getLexeme: identifier average@4
expression: start with stopSet = [semicolon, rbracket, endlexeme]
checkOrSkip: start
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
checkOrSkip: end
getLexeme: )
expression: end
checkOrSkip: start
checkOrSkip: lexeme "rbracket" in okSet [rbracket]
checkOrSkip: end
getLexeme: ;
checkOrSkip: start
checkOrSkip: lexeme "semicolon" in okSet [semicolon]
checkOrSkip: end
}
getLexeme: }
->plant (accInUse=false):
 41 :acc= variable 4
->plant (accInUse=true):
 42 :acc=> stack
->plant (accInUse=true):
 43 :call write
writeStatement: end
statement: end
statements: end
checkOrSkip: start
checkOrSkip: lexeme "endlexeme" in okSet [endlexeme]
checkOrSkip: end
prog: end
->plant (accInUse=true):
 44 :stop