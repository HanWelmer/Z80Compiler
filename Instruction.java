/**
 * This class defines an instruction for the M machine as generated by the P language.
 * Used in the code generation phase of the compiler.
 */
public class Instruction {
  public FunctionType function;
  //TODO refactor opType and word into operand.
  public CallType callValue;  /* for call functions */
  public OperandType opType; /* for load, store and arithmetic functions */
  public SpecialOperand specialOperand; /* ditto with opType == special  */
  public int word;            /* value for branch and accu related functions */

  public Instruction(FunctionType fn) {
    function = fn;
  }

  public Instruction(FunctionType fn, Operand operand) {
    if (fn != FunctionType.accLoad) {
      throw new RuntimeException("new Instruction with Operand without FunctionType accLoad");
    }
    function = fn;
    opType = operand.opType;
    if (operand.opType == OperandType.special) {
      //TODO moet dit stack of unstack zijn?
      specialOperand = SpecialOperand.stack;
    } else {
      word = operand.opValue;
    }
  }
  
  public Instruction(FunctionType fn, int value) {
    if (fn != FunctionType.br
      && fn != FunctionType.brEq 
      && fn != FunctionType.brNe
      && fn != FunctionType.brLt
      && fn != FunctionType.brLe
      && fn != FunctionType.brGt
      && fn != FunctionType.brGe) {
      throw new RuntimeException("new Instruction without FunctionType branch");
    }
    function = fn;
    word = value;
  }

  public Instruction(FunctionType fn, OperandType operandType) {
    if (operandType == OperandType.label) {
      throw new RuntimeException("new accu related Instruction with OperandType label");
    }
    if (fn != FunctionType.accLoad
     && fn != FunctionType.accStore
     && fn != FunctionType.stackAccLoad
     && fn != FunctionType.accPlus
     && fn != FunctionType.accMinus
     && fn != FunctionType.minusAcc
     && fn != FunctionType.accTimes
     && fn != FunctionType.accDiv
     && fn != FunctionType.divAcc
     && fn != FunctionType.accCompare
     ) {
      throw new RuntimeException("new non accu related Instruction with OperandType");
    }
    function = fn;
    opType = operandType;
    if ((fn == FunctionType.stackAccLoad) && (operandType == OperandType.special)) {
      throw new RuntimeException("new stackAccLoad Instruction with OperandType special");
    } else if (fn == FunctionType.accStore) {
      specialOperand = SpecialOperand.stack;
    } else {
      /* fn == FunctionType.accLoad
      || fn == FunctionType.stackAccLoad
      || fn == FunctionType.accPlus
      || fn == FunctionType.accMinus
      || fn == FunctionType.minusAcc
      || fn == FunctionType.accTimes
      || fn == FunctionType.accDiv
      || fn == FunctionType.divAcc
      || fn == FunctionType.accCompare
      */
      specialOperand = SpecialOperand.unstack;
    }
  }
  
  public Instruction(FunctionType fn, CallType type) {
    if (type == CallType.address) {
      throw new RuntimeException("new Instruction without CallType address");
    }
    function = fn;
    callValue = type;
  }

  public Instruction(FunctionType fn, CallType type, int value) {
    if (!((fn == FunctionType.accLoad) && (type == CallType.address)
      || (fn == FunctionType.call) && (type == CallType.address))) {
      throw new RuntimeException("new Instruction without Functionype accLoad or call and CallType address ");
    }
    function = fn;
    callValue = type;
    word = value;
  }
  
  public Instruction(FunctionType fn, OperandType type, int value) {
    if (!((  (fn == FunctionType.accLoad) 
          || (fn == FunctionType.accStore) 
          || (fn == FunctionType.stackAccLoad) 
          || (fn == FunctionType.accPlus) 
          || (fn == FunctionType.accMinus)
          || (fn == FunctionType.minusAcc)
          || (fn == FunctionType.accTimes)
          || (fn == FunctionType.accDiv)
          || (fn == FunctionType.divAcc)
          || (fn == FunctionType.accCompare)
          ) 
        && ((type == OperandType.constant) || (type == OperandType.var))
        )) {
      throw new RuntimeException("new Instruction without CallType accLoad and OperandType constant or var");
    }
    function = fn;
    opType = type;
    word = value;
  }
  
  public String toString() {
    String result = function.getValue();
    switch (function) {
      case accLoad:
      case accStore:
      case stackAccLoad:
      case accPlus:
      case accMinus:
      case minusAcc:
      case accTimes:
      case accDiv:
      case divAcc:
      case accCompare:
        /*
          public FunctionType function;
          public CallType callValue;              // for call functions
          public OperandType opType;              // for load, store and arithmetic functions
          public SpecialOperand specialOperand;   // ditto with opType == special
          public int word;                        // value for branch and accu related functions
        */
        switch(opType) {
          case var: result += " variable " + word; break;
          case constant: result += " constant " + word; break;
          case special:
            switch(specialOperand) {
              case stack: result += " stack"; break;
              case unstack: result += " unstack"; break;
            }
            break;
        };
        break;
      case br:
      case brNe:
      case brEq:
      case brLt:
      case brLe:
      case brGe:
      case brGt:
        result += " " + word;
        break;
      case call:
        if (callValue == CallType.read) {
          result += " read";
        } else if (callValue == CallType.write) {
          result += " write";
        } else {
          result += " " + word;
        }
        break;
      case stop: /* */ break;
    }
    return result;
  }
}
