import java.util.ArrayList;
/**
 * This class defines an instruction for the M machine as generated by the P language.
 * Used in the code generation phase of the compiler.
 */
public class Instruction {
  public FunctionType function;
  public Operand operand;
  
  /* original source code lines */
  public ArrayList<String> linesOfCode = new ArrayList<String>(0);

  public Instruction(FunctionType fn) {
    function = fn;
    
    //error detection (internal compiler errors):
    if (function != FunctionType.stop && function != FunctionType.read && function != FunctionType.write) {
      throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
    }
  }

  public Instruction(FunctionType fn, Operand operand) {
    function = fn;
    
    //error detection (internal compiler errors):
    switch (function) {
      case stop:
      case read:
      case write:
        throw new RuntimeException("Internal compiler error: functionType " + fn + " expects no operand.");
        //break;
      case call:
        throw new RuntimeException("Internal compiler error: functionType " + fn + " not yet implemented.");
        //break;
      case accLoad:
      case stackAccLoad:
      case accPlus:
      case accMinus:
      case minusAcc:
      case accTimes:
      case accDiv:
      case divAcc:
      case accCompare:
        if (operand == null) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
        } else if (operand.opType == OperandType.stack) {
          if (function == FunctionType.stackAccLoad) {
            throw new RuntimeException("Internal compiler error: illegal operand type " + operand.opType + " for functionType " + fn);
          } else if (operand.opValue == null) {
            //no error
          } else {
            throw new RuntimeException("Internal compiler error: functionType " + fn + " expects null as operand value.");
          }
        } else if (operand.opType == OperandType.constant || operand.opType == OperandType.var) {
          if (operand.opValue == null) {
            throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand value.");
          }
        } else if (operand.opType == OperandType.label) {
          throw new RuntimeException("Internal compiler error: illegal operand type " + operand.opType + " for functionType " + fn);
        } else {
          throw new RuntimeException("Internal compiler error: unknown operand type " + operand.opType + " for functionType " + fn);
        }
        break;
      case accStore:
        if (operand == null) {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an operand.");
        } else if (operand.opType == OperandType.stack) {
          if (operand.opValue == null) {
            throw new RuntimeException("Internal compiler error: functionType " + fn + " expects null as operand value.");
          }
        } else if (operand.opType == OperandType.var) {
          if (operand.opValue == null) {
            throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an address for its variable operand.");
          }
        } else if (operand.opType == OperandType.constant || operand.opType == OperandType.label) {
          throw new RuntimeException("Internal compiler error: illegal operand type " + operand.opType + " for functionType " + fn);
        } else {
          throw new RuntimeException("Internal compiler error: unknown operand type " + operand.opType + " for functionType " + fn);
        };
        break;
      case increment:
      case decrement:
        if (operand != null && operand.opType == OperandType.var) {
          if (operand.opValue == null) {
            throw new RuntimeException("Internal compiler error: functionType " + fn + " expects an address for its variable operand.");
          }
        } else {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects a variable as operand.");
        };
        break;
      case br:
      case brEq:
      case brNe:
      case brLt:
      case brLe:
      case brGt:
      case brGe:
        if (operand != null && operand.opType == OperandType.label) {
          if (operand.opValue == null) {
            throw new RuntimeException("Internal compiler error: functionType " + fn + " expects the address of a label to jump to.");
          }
        } else {
          throw new RuntimeException("Internal compiler error: functionType " + fn + " expects a label to jump to.");
        };
        break;
      default :
        throw new RuntimeException("Internal compiler error: unknown functionType " + fn);
    }
    
    //deep copy of operand, otherwise a reference to the mutable object operand is copied into the Instruction.
    this.operand = new Operand(operand.opType, operand.opValue, operand.opSize);
  }
  
  public String toString() {
    String result = function.getValue();
    switch (function) {
      case accStore:
        switch(operand.opType) {
          case var: result += " variable " + operand.opValue; break;
          case stack: result += " stack"; break;
          default: throw new RuntimeException("accStore with unsupported operandType");
        };
        break;
      case accLoad:
      case stackAccLoad:
      case accPlus:
      case accMinus:
      case minusAcc:
      case accTimes:
      case accDiv:
      case divAcc:
      case accCompare:
        switch(operand.opType) {
          case var: result += " variable " + operand.opValue; break;
          case constant: result += " constant " + operand.opValue; break;
          case stack: result += " unstack"; break;
          default: throw new RuntimeException("accu related instruction with unsupported operandType");
        };
        break;
      case increment:
      case decrement:
        switch(operand.opType) {
          case var: result += " variable " + operand.opValue; break;
          default: throw new RuntimeException(result + " instruction with non-var operandType");
        };
        break;
      case br:
      case brNe:
      case brEq:
      case brLt:
      case brLe:
      case brGe:
      case brGt:
      case call:
        result += " " + operand.opValue;
        break;
      case read:
        result = "call read";
        break;
      case write:
        result = "call write";
        break;
      case stop:
        break;
      default: throw new RuntimeException("unsupported instruction");
    }
    return result;
  }
}
