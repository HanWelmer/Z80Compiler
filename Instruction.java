import java.util.ArrayList;
/**
 * This class defines an instruction for the M machine as generated by the P language.
 * Used in the code generation phase of the compiler.
 */
public class Instruction {
  public FunctionType function;
  public OperandType opType;   // for load, store and arithmetic functions.
  public int word;             // value for branch, call and accu related functions.
  
  /* original source code lines */
  public ArrayList<String> linesOfCode = new ArrayList<String>(0);

  public Instruction(FunctionType fn) {
    function = fn;
  }

  public Instruction(FunctionType fn, Operand operand) {
    if (fn != FunctionType.accLoad) {
      throw new RuntimeException("new Instruction with Operand without FunctionType accLoad");
    }
    function = fn;
    opType = operand.opType;
    word = operand.opValue;
  }
  
  public Instruction(FunctionType fn, int value) {
    if (fn != FunctionType.br
      && fn != FunctionType.brEq 
      && fn != FunctionType.brNe
      && fn != FunctionType.brLt
      && fn != FunctionType.brLe
      && fn != FunctionType.brGt
      && fn != FunctionType.brGe
      && fn != FunctionType.call) {
      throw new RuntimeException("new Instruction without FunctionType branch");
    }
    function = fn;
    word = value;
  }

  public Instruction(FunctionType fn, OperandType operandType) {
    if (operandType == OperandType.label) {
      throw new RuntimeException("new accu related Instruction with OperandType label");
    }

    if (fn != FunctionType.accLoad
     && fn != FunctionType.accStore
     && fn != FunctionType.stackAccLoad
     && fn != FunctionType.accPlus
     && fn != FunctionType.accMinus
     && fn != FunctionType.minusAcc
     && fn != FunctionType.accTimes
     && fn != FunctionType.accDiv
     && fn != FunctionType.divAcc
     && fn != FunctionType.accCompare
     ) {
      throw new RuntimeException("new non accu related Instruction with OperandType");
    }

    function = fn;
    opType = operandType;
    if ((fn == FunctionType.stackAccLoad) && (operandType == OperandType.stack)) {
      throw new RuntimeException("new stackAccLoad Instruction with OperandType stack");
    //} else if (fn == FunctionType.accStore) {
    //  opType = OperandType.stack;
    }
  }
  
  public Instruction(FunctionType fn, OperandType type, int value) {
    if (!((  (fn == FunctionType.accLoad) 
          || (fn == FunctionType.accStore) 
          || (fn == FunctionType.stackAccLoad) 
          || (fn == FunctionType.accPlus) 
          || (fn == FunctionType.accMinus)
          || (fn == FunctionType.minusAcc)
          || (fn == FunctionType.accTimes)
          || (fn == FunctionType.accDiv)
          || (fn == FunctionType.divAcc)
          || (fn == FunctionType.accCompare)
          ) 
        && ((type == OperandType.constant) || (type == OperandType.var))
        )) {
      throw new RuntimeException("new Instruction without FunctionType accLoad and OperandType constant or var");
    }
    function = fn;
    opType = type;
    word = value;
  }
  
  public String toString() {
    /*
      public FunctionType function;
      public OperandType opType;    // for load, store and arithmetic functions.
      public int word;              // value for branch, call and accu related functions.
    */
    String result = function.getValue();
    switch (function) {
      case accStore:
        switch(opType) {
          case var: result += " variable " + word; break;
          case stack: stack: result += " stack"; break;
          default: throw new RuntimeException("accStore with unsupported operandType");
        };
        break;
      case accLoad:
      case stackAccLoad:
      case accPlus:
      case accMinus:
      case minusAcc:
      case accTimes:
      case accDiv:
      case divAcc:
      case accCompare:
        switch(opType) {
          case var: result += " variable " + word; break;
          case constant: result += " constant " + word; break;
          case stack: stack: result += " unstack"; break;
          default: throw new RuntimeException("accu related instruction with unsupported operandType");
        };
        break;
      case br:
      case brNe:
      case brEq:
      case brLt:
      case brLe:
      case brGe:
      case brGt:
      case call:
        result += " " + word;
        break;
      case read:
        result = "call read";
        break;
      case write:
        result = "call write";
        break;
      case stop:
        break;
      default: throw new RuntimeException("unsupported instruction");
    }
    return result;
  }
}
