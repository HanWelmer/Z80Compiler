debug = true
z80CodeGeneration = false
binaryCodeGeneration = false

prog start
{A small program in the P-language}

VAR S, N, T;

lexeme=VAR
lexeme=name S
idlist start
checkOrSkip: lexeme "identifier" in okSet [identifier]
name S@0
lexeme=,
idlist var declared
checkOrSkip: lexeme "comma" in okSet [comma, semicolon]
idlist ; or , ignored
idlist , skipped
lexeme=name N
checkOrSkip: lexeme "identifier" in okSet [identifier]
name N@1
lexeme=,
idlist var declared
checkOrSkip: lexeme "comma" in okSet [comma, semicolon]
idlist ; or , ignored
idlist , skipped
lexeme=name T
checkOrSkip: lexeme "identifier" in okSet [identifier]
name T@2
lexeme=;
idlist var declared
checkOrSkip: lexeme "semicolon" in okSet [comma, semicolon]
idlist ; or , ignored
idlist end of id list reached
idlist ; skipped
BEGIN

  S := 0; {sum}

lexeme=BEGIN
idlist end
block: start
checkOrSkip: lexeme "beginlexeme" in okSet [dot, identifier, beginlexeme, writelexeme, iflexeme, whilelexeme]
lexeme=name S@0
block: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=:=
checkOrSkip: lexeme "assign" in okSet [assign]
lexeme=digit 0
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=;
->plant (accInUse=false):
  0 :acc= constant 0
->plant (accInUse=true):
  1 :acc=> variable 0
statement: end
block: end
checkOrSkip: lexeme "semicolon" in okSet [semicolon, endlexeme]
  N := 0; {number of items}

lexeme=name N@1
block: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=:=
checkOrSkip: lexeme "assign" in okSet [assign]
lexeme=digit 0
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=;
->plant (accInUse=false):
  2 :acc= constant 0
->plant (accInUse=true):
  3 :acc=> variable 1
statement: end
block: end
checkOrSkip: lexeme "semicolon" in okSet [semicolon, endlexeme]
  T := READ; {read a digit}

lexeme=name T@2
block: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=:=
checkOrSkip: lexeme "assign" in okSet [assign]
lexeme=READ
checkOrSkip: lexeme "readlexeme" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=;
->plant (accInUse=false):
  4 :call read
->plant (accInUse=true):
  5 :acc=> variable 2
statement: end
block: end
checkOrSkip: lexeme "semicolon" in okSet [semicolon, endlexeme]
  WHILE T <> 0 {not end of file} DO

lexeme=WHILE
block: start
checkOrSkip: lexeme "whilelexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "whilelexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start while loop
lexeme=name T@2
label:
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=<=> ne
->plant (accInUse=false):
  6 :acc= variable 2
checkOrSkip: lexeme "relop" in okSet [relop]
lexeme=digit 0
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
  BEGIN

lexeme=DO
->plant (accInUse=true):
  7 :accom constant 0
label used
->plant (accInUse=true):
  8 :breq 0
checkOrSkip: lexeme "dolexeme" in okSet [dolexeme]
    S := S + T; {sum of numbers read}

lexeme=BEGIN
block: start
checkOrSkip: lexeme "beginlexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=name S@0
block: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=:=
checkOrSkip: lexeme "assign" in okSet [assign]
lexeme=name S@0
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=+ or - add
->plant (accInUse=false):
  9 :acc= variable 0
lexeme=name T@2
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=;
->plant (accInUse=true):
 10 :acc+ variable 2
->plant (accInUse=true):
 11 :acc=> variable 0
statement: end
block: end
checkOrSkip: lexeme "semicolon" in okSet [semicolon, endlexeme]
    N := N + 1; {number of numbers read}

lexeme=name N@1
block: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=:=
checkOrSkip: lexeme "assign" in okSet [assign]
lexeme=name N@1
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=+ or - add
->plant (accInUse=false):
 12 :acc= variable 1
lexeme=digit 1
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=;
->plant (accInUse=true):
 13 :acc+ constant 1
->plant (accInUse=true):
 14 :acc=> variable 1
statement: end
block: end
checkOrSkip: lexeme "semicolon" in okSet [semicolon, endlexeme]
    T := READ;

lexeme=name T@2
block: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "identifier" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=:=
checkOrSkip: lexeme "assign" in okSet [assign]
lexeme=READ
checkOrSkip: lexeme "readlexeme" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=;
->plant (accInUse=false):
 15 :call read
->plant (accInUse=true):
 16 :acc=> variable 2
statement: end
block: end
checkOrSkip: lexeme "semicolon" in okSet [semicolon, endlexeme]
  END;

lexeme=END
block: start
checkOrSkip: lexeme "endlexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "endlexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: end
block: end
checkOrSkip: lexeme "endlexeme" in okSet [semicolon, endlexeme]
lexeme=;
block: end
->plant (accInUse=false):
 17 :br 6
label: used from 8
statement: end of while loop
statement: end
block: end
checkOrSkip: lexeme "semicolon" in okSet [semicolon, endlexeme]
  WRITE (N);

lexeme=WRITE
block: start
checkOrSkip: lexeme "writelexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "writelexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=(
checkOrSkip: lexeme "lbracket" in okSet [lbracket]
lexeme=name N@1
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=)
->plant (accInUse=false):
 18 :acc= variable 1
checkOrSkip: lexeme "rbracket" in okSet [rbracket]
lexeme=;
->plant (accInUse=true):
 19 :acc=> stack
->plant (accInUse=true):
 20 :call write
statement: end
block: end
checkOrSkip: lexeme "semicolon" in okSet [semicolon, endlexeme]
  WRITE (S);

lexeme=WRITE
block: start
checkOrSkip: lexeme "writelexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "writelexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=(
checkOrSkip: lexeme "lbracket" in okSet [lbracket]
lexeme=name S@0
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=)
->plant (accInUse=false):
 21 :acc= variable 0
checkOrSkip: lexeme "rbracket" in okSet [rbracket]
lexeme=;
->plant (accInUse=true):
 22 :acc=> stack
->plant (accInUse=true):
 23 :call write
statement: end
block: end
checkOrSkip: lexeme "semicolon" in okSet [semicolon, endlexeme]
  IF N <> 0 THEN

lexeme=IF
block: start
checkOrSkip: lexeme "iflexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "iflexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=name N@1
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=<=> ne
->plant (accInUse=false):
 24 :acc= variable 1
checkOrSkip: lexeme "relop" in okSet [relop]
lexeme=digit 0
checkOrSkip: lexeme "constant" in okSet [constant, identifier, lbracket, readlexeme]
    WRITE (S / N); {average}

lexeme=THEN
->plant (accInUse=true):
 25 :accom constant 0
label used
->plant (accInUse=true):
 26 :breq 0
checkOrSkip: lexeme "thenlexeme" in okSet [thenlexeme]
lexeme=WRITE
block: start
checkOrSkip: lexeme "writelexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "writelexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
lexeme=(
checkOrSkip: lexeme "lbracket" in okSet [lbracket]
lexeme=name S@0
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=* or / divd
->plant (accInUse=false):
 27 :acc= variable 0
lexeme=name N@1
checkOrSkip: lexeme "identifier" in okSet [constant, identifier, lbracket, readlexeme]
lexeme=)
->plant (accInUse=true):
 28 :acc/ variable 1
checkOrSkip: lexeme "rbracket" in okSet [rbracket]
lexeme=;
->plant (accInUse=true):
 29 :acc=> stack
->plant (accInUse=true):
 30 :call write
statement: end
block: end
label: used from 26
statement: end
block: end
checkOrSkip: lexeme "semicolon" in okSet [semicolon, endlexeme]
END.

lexeme=END
block: start
checkOrSkip: lexeme "endlexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: start
checkOrSkip: lexeme "endlexeme" in okSet [dot, identifier, semicolon, beginlexeme, writelexeme, iflexeme, whilelexeme, endlexeme]
statement: end
block: end
checkOrSkip: lexeme "endlexeme" in okSet [semicolon, endlexeme]
lexeme=.
block: end
checkOrSkip: lexeme "dot" in okSet [dot]
prog end
->plant (accInUse=false):
 31 :stop
Assembly listing of compiled code:
----------------------------------
  0 :acc= constant 0
  1 :acc=> variable 0
  2 :acc= constant 0
  3 :acc=> variable 1
  4 :call read
  5 :acc=> variable 2
  6 :acc= variable 2
  7 :accom constant 0
  8 :breq 18
  9 :acc= variable 0
 10 :acc+ variable 2
 11 :acc=> variable 0
 12 :acc= variable 1
 13 :acc+ constant 1
 14 :acc=> variable 1
 15 :call read
 16 :acc=> variable 2
 17 :br 6
 18 :acc= variable 1
 19 :acc=> stack
 20 :call write
 21 :acc= variable 0
 22 :acc=> stack
 23 :call write
 24 :acc= variable 1
 25 :accom constant 0
 26 :breq 31
 27 :acc= variable 0
 28 :acc/ variable 1
 29 :acc=> stack
 30 :call write
 31 :stop

Running compiled code...

pc=0 : acc= constant 0
pc=1 : acc=> variable 0
pc=2 : acc= constant 0
pc=3 : acc=> variable 1
pc=4 : call readread:
*** runtime error: read exception:null
pc=4 : call read

variable 0 = 0
variable 1 = 0
variable 2 = 0
variable 3 = 0
variable 4 = 0
variable 5 = 0
variable 6 = 0
variable 7 = 0
variable 8 = 0
variable 9 = 0
variable 10 = 0
variable 11 = 0
variable 12 = 0
variable 13 = 0
variable 14 = 0
variable 15 = 0
variable 16 = 0
variable 17 = 0
variable 18 = 0
variable 19 = 0
variable 20 = 0
variable 21 = 0
variable 22 = 0
variable 23 = 0
variable 24 = 0
variable 25 = 0

accumulator = 0
stackpointer= 0


